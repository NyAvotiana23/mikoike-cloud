============================================================
FILE: AuthService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.UserRecord;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.*;
import mg.projetfinal.enums.FailureReason;
import mg.projetfinal.repository.*;
import mg.projetfinal.utils.NetworkUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final SessionRepository sessionRepository;
    private final LoginAttemptRepository loginAttemptRepository;
    private final FailedLoginTrackingRepository failedLoginTrackingRepository;
    private final PasswordEncoder passwordEncoder;
    private final FailedLoginTrackingService failedLoginTrackingService;

    @Value("${auth.max-attempts:3}")
    private int maxAttempts;

    @Value("${session.expiry-minutes:30}")
    private int sessionExpiryMinutes;

    @Value("${auth.lockout-duration-minutes:30}")
    private int lockoutDurationMinutes;

    @Value("${app.mode:online}")
    private String appMode;

    // ==================== INSCRIPTION ====================

    @Transactional
    public User register(String email, String password, String name, User createdBy) {
        // Vérifier si email existe déjà
        if (userRepository.existsByEmail(email)) {
            throw new RuntimeException("Email déjà utilisé");
        }

        // Récupérer le rôle par défaut (UTILISATEUR)
        Role defaultRole = roleRepository.findByCode("UTILISATEUR")
                .orElseThrow(() -> new RuntimeException("Rôle UTILISATEUR introuvable"));

        // Créer l'utilisateur
        User user = User.builder()
                .email(email)
                .passwordHash(passwordEncoder.encode(password))
                .name(name)
                .role(defaultRole)
                .firebaseSynced(false)
                .isLocked(false)
                .failedAttempts(0)
                .createdBy(createdBy)
                .build();

        // Synchronisation Firebase si mode online
        if (isOnline()) {
            try {
                UserRecord.CreateRequest request = new UserRecord.CreateRequest()
                        .setEmail(email)
                        .setPassword(password)
                        .setDisplayName(name);

                UserRecord firebaseUser = FirebaseAuth.getInstance().createUser(request);
                user.setFirebaseUid(firebaseUser.getUid());
                user.setFirebaseSynced(true);
                user.setSyncedAt(LocalDateTime.now());

                log.info("User créé dans Firebase: {}", firebaseUser.getUid());
            } catch (FirebaseAuthException e) {
                user.setFirebaseSyncError(e.getMessage());
                log.error("Erreur création Firebase: {}", e.getMessage());
            }
        }

        return userRepository.save(user);
    }

    @Transactional
    public User registerAdmin(String email, String password, String name) {
        // Vérifier si email existe déjà
        if (userRepository.existsByEmail(email)) {
            throw new RuntimeException("Email déjà utilisé");
        }

        // Récupérer le rôle MANAGER
        Role managerRole = roleRepository.findByCode("MANAGER")
                .orElseThrow(() -> new RuntimeException("Rôle MANAGER introuvable"));

        // Créer l'utilisateur admin
        User admin = User.builder()
                .email(email)
                .passwordHash(passwordEncoder.encode(password))
                .name(name)
                .role(managerRole)
                .firebaseSynced(false)
                .isLocked(false)
                .failedAttempts(0)
                .build();

        // Synchronisation Firebase si mode online
        if (isOnline()) {
            try {
                UserRecord.CreateRequest request = new UserRecord.CreateRequest()
                        .setEmail(email)
                        .setPassword(password)
                        .setDisplayName(name);

                UserRecord firebaseUser = FirebaseAuth.getInstance().createUser(request);
                admin.setFirebaseUid(firebaseUser.getUid());
                admin.setFirebaseSynced(true);
                admin.setSyncedAt(LocalDateTime.now());

                log.info("Admin créé dans Firebase: {}", firebaseUser.getUid());
            } catch (FirebaseAuthException e) {
                admin.setFirebaseSyncError(e.getMessage());
                log.error("Erreur création Firebase admin: {}", e.getMessage());
            }
        }

        User savedAdmin = userRepository.save(admin);
        log.info("Admin créé avec succès: {}", email);
        return savedAdmin;
    }

    // ==================== CONNEXION ====================

    @Transactional
    public Session login(String email, String password, HttpServletRequest request) {
        String ipAddress = getClientIp(request);
        String userAgent = request.getHeader("User-Agent");

        // Étape 1: Vérifier blocage dans failed_login_tracking
        Optional<FailedLoginTracking> trackingOpt = failedLoginTrackingRepository.findByEmail(email);
        if (trackingOpt.isPresent()) {
            FailedLoginTracking tracking = trackingOpt.get();
            if (tracking.isCurrentlyBlocked()) {
                recordLoginAttempt(email, null, false, FailureReason.ACCOUNT_LOCKED, ipAddress, userAgent);
                throw new RuntimeException("Compte bloqué jusqu'à " + tracking.getBlockedUntil());
            }
        }

        // Étape 2: Chercher l'utilisateur
        Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isEmpty()) {
            recordLoginAttempt(email, null, false, FailureReason.USER_NOT_FOUND, ipAddress, userAgent);
            throw new RuntimeException("Email ou mot de passe incorrect");
        }

        User user = userOpt.get();

        // Étape 3: Vérifier blocage dans users
        if (user.isAccountLocked()) {
            recordLoginAttempt(email, user, false, FailureReason.ACCOUNT_LOCKED, ipAddress, userAgent);
            throw new RuntimeException("Compte verrouillé jusqu'à " + user.getLockedUntil());
        }

        // Étape 4: Vérifier le mot de passe
        if (!passwordEncoder.matches(password, user.getPasswordHash())) {
            recordLoginAttempt(email, user, false, FailureReason.INVALID_PASSWORD, ipAddress, userAgent);

            // Utiliser le service avec REQUIRES_NEW pour persister même si exception
            int remainingAttempts = failedLoginTrackingService.handleFailedLogin(email, user, maxAttempts, lockoutDurationMinutes);

            if (remainingAttempts <= 0) {
                throw new RuntimeException("Compte bloqué pour " + lockoutDurationMinutes + " minutes suite à trop de tentatives échouées");
            }

            throw new RuntimeException("Email ou mot de passe incorrect. Tentatives restantes: " + remainingAttempts);
        }

        // Étape 5: Vérifier si déjà connecté
        List<Session> activeSessions = sessionRepository.findByUserAndIsActiveTrue(user);
        for (Session activeSession : activeSessions) {
            if (activeSession.isValid()) {
                throw new RuntimeException("Utilisateur déjà connecté. Veuillez vous déconnecter d'abord ou utiliser /logout-all");
            }
        }

        // Étape 6: Vérifier Firebase si online
        if (isOnline()) {
            try {
                FirebaseAuth.getInstance().getUserByEmail(email);
            } catch (FirebaseAuthException e) {
                recordLoginAttempt(email, user, false, FailureReason.FIREBASE_ERROR, ipAddress, userAgent);
                log.error("Erreur Firebase lors du login: {}", e.getMessage());
                throw new RuntimeException("Erreur de synchronisation Firebase");
            }
        }

        // Étape 7: Connexion réussie - Reset des tentatives échouées
        recordLoginAttempt(email, user, true, null, ipAddress, userAgent);

        // Reset tracking
        if (trackingOpt.isPresent()) {
            FailedLoginTracking tracking = trackingOpt.get();
            tracking.reset();
            failedLoginTrackingRepository.save(tracking);
        }

        // Reset user
        user.resetFailedAttempts();
        userRepository.save(user);

        // Créer une session
        return createSession(user, ipAddress, userAgent);
    }

    @Transactional
    public Session loginManager(String email, String password, HttpServletRequest request) {
        String ipAddress = getClientIp(request);
        String userAgent = request.getHeader("User-Agent");

        // Chercher l'utilisateur
        Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isEmpty()) {
            recordLoginAttempt(email, null, false, FailureReason.USER_NOT_FOUND, ipAddress, userAgent);
            throw new RuntimeException("Email ou mot de passe incorrect");
        }

        User user = userOpt.get();

        // Vérifier que c'est un manager
        if (!user.isManager()) {
            recordLoginAttempt(email, user, false, FailureReason.INVALID_PASSWORD, ipAddress, userAgent);
            throw new RuntimeException("Accès réservé aux managers");
        }

        // Vérifier le mot de passe (SANS blocage)
        if (!passwordEncoder.matches(password, user.getPasswordHash())) {
            recordLoginAttempt(email, user, false, FailureReason.INVALID_PASSWORD, ipAddress, userAgent);
            throw new RuntimeException("Email ou mot de passe incorrect");
        }

        // Vérifier si déjà connecté
        List<Session> activeSessions = sessionRepository.findByUserAndIsActiveTrue(user);
        for (Session activeSession : activeSessions) {
            if (activeSession.isValid()) {
                throw new RuntimeException("Utilisateur déjà connecté. Veuillez vous déconnecter d'abord");
            }
        }

        // Vérifier Firebase si online
//        if (isOnline()) {
//            try {
//                FirebaseAuth.getInstance().getUserByEmail(email);
//            } catch (FirebaseAuthException e) {
//                recordLoginAttempt(email, user, false, FailureReason.FIREBASE_ERROR, ipAddress, userAgent);
//                log.error("Erreur Firebase lors du login manager: {}", e.getMessage());
//                throw new RuntimeException("Erreur de synchronisation Firebase");
//            }
//        }

        // Connexion réussie
        recordLoginAttempt(email, user, true, null, ipAddress, userAgent);

        // Créer une session
        return createSession(user, ipAddress, userAgent);
    }

    // ==================== MODIFICATION USER ====================

    @Transactional
    public User updateUser(Long userId, String name, String password, User modifiedBy) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur introuvable"));

        // Vérifier les permissions (seul le user lui-même ou un manager peut modifier)
        if (!modifiedBy.getId().equals(userId) && !modifiedBy.isManager()) {
            throw new RuntimeException("Permission refusée");
        }

        // Mettre à jour les infos
        if (name != null && !name.isEmpty()) {
            user.setName(name);
        }

        if (password != null && !password.isEmpty()) {
            user.setPasswordHash(passwordEncoder.encode(password));
        }

        // Synchroniser avec Firebase si online
        if (isOnline() && user.getFirebaseUid() != null) {
            try {
                UserRecord.UpdateRequest request = new UserRecord.UpdateRequest(user.getFirebaseUid());

                if (name != null && !name.isEmpty()) {
                    request.setDisplayName(name);
                }
                if (password != null && !password.isEmpty()) {
                    request.setPassword(password);
                }

                FirebaseAuth.getInstance().updateUser(request);
                user.setFirebaseSynced(true);
                user.setSyncedAt(LocalDateTime.now());
                user.setFirebaseSyncError(null);

                log.info("User mis à jour dans Firebase: {}", user.getFirebaseUid());
            } catch (FirebaseAuthException e) {
                user.setFirebaseSynced(false);
                user.setFirebaseSyncError(e.getMessage());
                log.error("Erreur mise à jour Firebase: {}", e.getMessage());
            }
        }

        return userRepository.save(user);
    }

    // ==================== GESTION SESSION ====================

    private Session createSession(User user, String ipAddress, String deviceInfo) {
        String token = UUID.randomUUID().toString();
        LocalDateTime expiresAt = LocalDateTime.now().plusMinutes(sessionExpiryMinutes);

        Session session = Session.builder()
                .user(user)
                .token(token)
                .ipAddress(ipAddress)
                .deviceInfo(deviceInfo)
                .expiresAt(expiresAt)
                .isActive(true)
                .build();

        return sessionRepository.save(session);
    }

    public Optional<Session> validateSession(String token) {
        Optional<Session> sessionOpt = sessionRepository.findByToken(token);

        if (sessionOpt.isEmpty()) {
            return Optional.empty();
        }

        Session session = sessionOpt.get();

        if (!session.isValid()) {
            return Optional.empty();
        }

        // Mettre à jour l'activité
        session.updateActivity();
        sessionRepository.save(session);

        return Optional.of(session);
    }

    @Transactional
    public Session logout(String token) {
        Optional<Session> sessionOpt = sessionRepository.findByToken(token);
        if (sessionOpt.isPresent()) {
            Session session = sessionOpt.get();

            // Vérifier si la session est déjà invalide
            if (!session.isValid()) {
                throw new RuntimeException("Session déjà déconnectée ou expirée");
            }

            session.invalidate();
            sessionRepository.save(session);
            return session;
        }
        throw new RuntimeException("Session introuvable");
    }

    @Transactional
    public void logoutAllUserSessions(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur introuvable"));
        sessionRepository.invalidateAllUserSessions(user);
    }

    // ==================== UTILITAIRE TEST - LOGOUT ALL ====================

    @Transactional
    public int logoutAllSessions() {
        List<Session> allSessions = sessionRepository.findAll();
        int count = 0;
        for (Session session : allSessions) {
            if (session.getIsActive()) {
                session.invalidate();
                sessionRepository.save(session);
                count++;
            }
        }
        log.info("Toutes les sessions déconnectées: {} sessions", count);
        return count;
    }

    // ==================== GESTION TENTATIVES ÉCHOUÉES ====================

    private void recordLoginAttempt(String email, User user, boolean success,
                                    FailureReason reason, String ipAddress, String userAgent) {
        LoginAttempt attempt = LoginAttempt.builder()
                .email(email)
                .user(user)
                .success(success)
                .failureReason(reason)
                .ipAddress(ipAddress)
                .userAgent(userAgent)
                .build();

        loginAttemptRepository.save(attempt);
    }

    // ==================== RESET TENTATIVES ====================

    @Transactional
    public void resetFailedAttempts(String email, User user) {
        // Reset tracking
        failedLoginTrackingRepository.findByEmail(email).ifPresent(tracking -> {
            tracking.reset();
            failedLoginTrackingRepository.save(tracking);
        });

        // Reset user
        if (user != null) {
            user.resetFailedAttempts();
            user.unlockAccount();
            userRepository.save(user);
        }
    }

    // ==================== API DÉBLOCAGE (MANAGER) ====================

    @Transactional
    public void unlockAccount(String email, User unlockedBy) {
        if (!unlockedBy.isManager()) {
            throw new RuntimeException("Seul un Manager peut débloquer un compte");
        }

        // Débloquer dans failed_login_tracking
        FailedLoginTracking tracking = failedLoginTrackingRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Aucun blocage trouvé pour cet email"));

        tracking.unblock(unlockedBy);
        failedLoginTrackingRepository.save(tracking);

        // Débloquer dans users
        userRepository.findByEmail(email).ifPresent(user -> {
            user.unlockAccount();
            userRepository.save(user);
        });

        log.info("Compte {} débloqué par le Manager {}", email, unlockedBy.getEmail());
    }

    // ==================== UTILITAIRES ====================

    private boolean isOnline() {
        return "online".equalsIgnoreCase(appMode) && NetworkUtils.isInternetAvailable();
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    // ==================== NETTOYAGE SESSIONS EXPIRÉES ====================

    @Transactional
    public void cleanupExpiredSessions() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime expirationDate = now.minusDays(7); // Garder 7 jours d'historique
        sessionRepository.deleteExpiredSessions(expirationDate);
        log.info("Sessions expirées nettoyées");
    }
}



============================================================
FILE: EntrepriseService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.EntrepriseRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class EntrepriseService {

    private final EntrepriseRepository entrepriseRepository;

    public Entreprise create(Entreprise entreprise, User createdBy) {
        log.info("Création d'une nouvelle entreprise: {}", entreprise.getNom());
        
        if (existsByNom(entreprise.getNom())) {
            throw new IllegalArgumentException("Une entreprise avec ce nom existe déjà");
        }
        
        if (entreprise.getSiret() != null && existsBySiret(entreprise.getSiret())) {
            throw new IllegalArgumentException("Une entreprise avec ce SIRET existe déjà");
        }
        
        entreprise.setCreatedBy(createdBy);
        entreprise.setIsActive(true);
        entreprise.setNombreInterventions(0);
        
        return entrepriseRepository.save(entreprise);
    }

    public Entreprise update(Integer id, Entreprise entreprise) {
        log.info("Mise à jour de l'entreprise avec l'ID: {}", id);
        
        Entreprise existingEntreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        if (!existingEntreprise.getNom().equals(entreprise.getNom())) {
            if (existsByNom(entreprise.getNom())) {
                throw new IllegalArgumentException("Une entreprise avec ce nom existe déjà");
            }
            existingEntreprise.setNom(entreprise.getNom());
        }
        
        if (entreprise.getSiret() != null && !entreprise.getSiret().equals(existingEntreprise.getSiret())) {
            if (existsBySiret(entreprise.getSiret())) {
                throw new IllegalArgumentException("Une entreprise avec ce SIRET existe déjà");
            }
            existingEntreprise.setSiret(entreprise.getSiret());
        }
        
        existingEntreprise.setTelephone(entreprise.getTelephone());
        existingEntreprise.setEmail(entreprise.getEmail());
        existingEntreprise.setAdresse(entreprise.getAdresse());
        existingEntreprise.setSpecialites(entreprise.getSpecialites());
        
        return entrepriseRepository.save(existingEntreprise);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findById(Integer id) {
        log.debug("Recherche de l'entreprise avec l'ID: {}", id);
        return entrepriseRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findAll() {
        log.debug("Récupération de toutes les entreprises");
        return entrepriseRepository.findAll();
    }

    public void delete(Integer id) {
        log.info("Suppression de l'entreprise avec l'ID: {}", id);
        
        if (!entrepriseRepository.existsById(id)) {
            throw new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id);
        }
        
        entrepriseRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findByNom(String nom) {
        log.debug("Recherche de l'entreprise par nom: {}", nom);
        return entrepriseRepository.findByNom(nom);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findBySiret(String siret) {
        log.debug("Recherche de l'entreprise par SIRET: {}", siret);
        return entrepriseRepository.findBySiret(siret);
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findActiveEntreprises() {
        log.debug("Récupération des entreprises actives");
        return entrepriseRepository.findByIsActiveTrue();
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findTopRatedEntreprises() {
        log.debug("Récupération des entreprises les mieux notées");
        return entrepriseRepository.findTopRatedEntreprises();
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findBySpecialite(String specialite) {
        log.debug("Recherche des entreprises par spécialité: {}", specialite);
        
        return entrepriseRepository.findByIsActiveTrue().stream()
                .filter(entreprise -> entreprise.getSpecialites() != null 
                        && Arrays.asList(entreprise.getSpecialites()).contains(specialite))
                .collect(Collectors.toList());
    }

    public Entreprise activateEntreprise(Integer id) {
        log.info("Activation de l'entreprise avec l'ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.setIsActive(true);
        return entrepriseRepository.save(entreprise);
    }

    public Entreprise deactivateEntreprise(Integer id) {
        log.info("Désactivation de l'entreprise avec l'ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.setIsActive(false);
        return entrepriseRepository.save(entreprise);
    }

    public void incrementInterventions(Integer id) {
        log.info("Incrémentation du nombre d'interventions pour l'entreprise ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.incrementInterventions();
        entrepriseRepository.save(entreprise);
    }

    public void updateNoteMoyenne(Integer id, BigDecimal nouvelleNote) {
        log.info("Mise à jour de la note moyenne pour l'entreprise ID: {}", id);
        
        if (nouvelleNote == null || nouvelleNote.compareTo(BigDecimal.ZERO) < 0 
                || nouvelleNote.compareTo(BigDecimal.valueOf(5)) > 0) {
            throw new IllegalArgumentException("La note doit être comprise entre 0 et 5");
        }
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.updateNoteMoyenne(nouvelleNote);
        entrepriseRepository.save(entreprise);
    }

    @Transactional(readOnly = true)
    public boolean existsByNom(String nom) {
        return entrepriseRepository.findByNom(nom).isPresent();
    }

    @Transactional(readOnly = true)
    public boolean existsBySiret(String siret) {
        return entrepriseRepository.findBySiret(siret).isPresent();
    }
}



============================================================
FILE: FailedLoginTrackingService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.FailedLoginTracking;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.FailedLoginTrackingRepository;
import mg.projetfinal.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class FailedLoginTrackingService {

    private final FailedLoginTrackingRepository failedLoginTrackingRepository;
    private final UserRepository userRepository;

    /**
     * Gère l'échec de connexion dans une transaction séparée
     * Retourne le nombre de tentatives restantes
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public int handleFailedLogin(String email, User user, int maxAttempts, int lockoutDurationMinutes) {
        // Récupérer ou créer le tracking
        FailedLoginTracking tracking = failedLoginTrackingRepository.findByEmail(email)
                .orElse(FailedLoginTracking.builder()
                        .email(email)
                        .failedCount(0)
                        .isBlocked(false)
                        .build());

        // Incrémenter
        tracking.recordFailedAttempt();
        failedLoginTrackingRepository.save(tracking);

        int remainingAttempts = maxAttempts - tracking.getFailedCount();

        // Bloquer si limite atteinte
        if (tracking.getFailedCount() >= maxAttempts) {
            tracking.blockAccount(lockoutDurationMinutes,
                    "Trop de tentatives de connexion échouées (" + maxAttempts + ")");
            failedLoginTrackingRepository.save(tracking);

            user.lockAccount(lockoutDurationMinutes);
            userRepository.save(user);

            log.warn("Compte bloqué pour {}: {} tentatives échouées", email, tracking.getFailedCount());
            return 0;
        }

        return remainingAttempts;
    }
}



============================================================
FILE: FirebaseSyncService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.*;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.UserRecord;
import com.google.firebase.cloud.FirestoreClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.*;
import mg.projetfinal.enums.*;
import mg.projetfinal.repository.*;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class FirebaseSyncService {

    private final UserRepository userRepository;
    private final SignalementRepository signalementRepository;
    private final EntrepriseRepository entrepriseRepository;
    private final SignalementStatusRepository signalementStatusRepository;
    private final SyncQueueRepository syncQueueRepository;
    private final SyncHistoryRepository syncHistoryRepository;

    private static final String COLLECTION_USERS = "users";
    private static final String COLLECTION_SIGNALEMENTS = "signalements";
    private static final String COLLECTION_ENTREPRISES = "entreprises";
    private static final String COLLECTION_STATUS = "signalement_status";

    // ==================== SYNCHRONISATION BIDIRECTIONNELLE ====================

    /**
     * Synchronisation complète bidirectionnelle
     * 1. PostgreSQL → Firebase (push local changes)
     * 2. Firebase → PostgreSQL (pull remote changes)
     */
    @Transactional
    public SyncResult syncAll() {
        log.info("=== Début de la synchronisation bidirectionnelle complète ===");
        SyncResult result = new SyncResult();

        try {
            // Phase 1: Push PostgreSQL → Firebase
            log.info("Phase 1: Synchronisation PostgreSQL → Firebase");
            result.addPostgresToFirebase(syncPostgresToFirebase());

            // Phase 2: Pull Firebase → PostgreSQL
            log.info("Phase 2: Synchronisation Firebase → PostgreSQL");
            result.addFirebaseToPostgres(syncFirebaseToPostgres());

            log.info("=== Synchronisation complète terminée avec succès ===");
            result.setSuccess(true);
        } catch (Exception e) {
            log.error("Erreur lors de la synchronisation bidirectionnelle", e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        }

        return result;
    }

    // ==================== POSTGRES → FIREBASE ====================

    /**
     * Synchronise toutes les entités de PostgreSQL vers Firebase
     */
    @Transactional
    public SyncResult syncPostgresToFirebase() {
        SyncResult result = new SyncResult();

        try {
            // Synchroniser les utilisateurs
            List<User> unsyncedUsers = userRepository.findNotSynced();
            for (User user : unsyncedUsers) {
                try {
                    syncUserToFirebase(user);
                    result.incrementSuccess("users");
                } catch (Exception e) {
                    log.error("Erreur sync user {}: {}", user.getId(), e.getMessage());
                    result.incrementError("users");
                    recordSyncError(EntityType.USER, user.getId(), e.getMessage());
                }
            }

            // Synchroniser les signalements
            List<Signalement> unsyncedSignalements = signalementRepository.findByFirebaseSyncedFalse();
            for (Signalement signalement : unsyncedSignalements) {
                try {
                    syncSignalementToFirebase(signalement);
                    result.incrementSuccess("signalements");
                } catch (Exception e) {
                    log.error("Erreur sync signalement {}: {}", signalement.getId(), e.getMessage());
                    result.incrementError("signalements");
                    recordSyncError(EntityType.SIGNALEMENT, signalement.getId(), e.getMessage());
                }
            }

            // Synchroniser les entreprises
            List<Entreprise> allEntreprises = entrepriseRepository.findAll();
            for (Entreprise entreprise : allEntreprises) {
                try {
                    syncEntrepriseToFirebase(entreprise);
                    result.incrementSuccess("entreprises");
                } catch (Exception e) {
                    log.error("Erreur sync entreprise {}: {}", entreprise.getId(), e.getMessage());
                    result.incrementError("entreprises");
                }
            }

            // Synchroniser les status
            List<SignalementStatus> allStatus = signalementStatusRepository.findAllByOrderByOrdreAsc();
            for (SignalementStatus status : allStatus) {
                try {
                    syncStatusToFirebase(status);
                    result.incrementSuccess("status");
                } catch (Exception e) {
                    log.error("Erreur sync status {}: {}", status.getId(), e.getMessage());
                    result.incrementError("status");
                }
            }

            result.setSuccess(true);
        } catch (Exception e) {
            log.error("Erreur globale sync Postgres → Firebase", e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        }

        return result;
    }

    /**
     * Synchronise un utilisateur vers Firebase (Auth + Firestore)
     */
    @Transactional
    public void syncUserToFirebase(User user) throws FirebaseAuthException, ExecutionException, InterruptedException {
        log.info("Synchronisation user {} vers Firebase", user.getId());
        Firestore firestore = FirestoreClient.getFirestore();

        // 1. Créer/Mettre à jour dans Firebase Authentication
        String firebaseUid;
        if (user.getFirebaseUid() == null || user.getFirebaseUid().isEmpty()) {
            // Créer un nouvel utilisateur Firebase Auth
            UserRecord.CreateRequest request = new UserRecord.CreateRequest()
                    .setEmail(user.getEmail())
                    .setPassword(generateTemporaryPassword()) // Mot de passe temporaire
                    .setDisplayName(user.getName())
                    .setEmailVerified(false);

            UserRecord firebaseUser = FirebaseAuth.getInstance().createUser(request);
            firebaseUid = firebaseUser.getUid();

            user.setFirebaseUid(firebaseUid);
            log.info("Utilisateur créé dans Firebase Auth: {}", firebaseUid);
        } else {
            // Mettre à jour l'utilisateur existant
            firebaseUid = user.getFirebaseUid();
            UserRecord.UpdateRequest request = new UserRecord.UpdateRequest(firebaseUid)
                    .setDisplayName(user.getName())
                    .setEmail(user.getEmail());

            FirebaseAuth.getInstance().updateUser(request);
            log.info("Utilisateur mis à jour dans Firebase Auth: {}", firebaseUid);
        }

        // 2. Synchroniser dans Firestore
        Map<String, Object> userData = new HashMap<>();
        userData.put("id", user.getId());
        userData.put("email", user.getEmail());
        userData.put("name", user.getName());
        userData.put("firebaseUid", firebaseUid);
        userData.put("roleCode", user.getRole() != null ? user.getRole().getCode() : null);
        userData.put("roleLibelle", user.getRole() != null ? user.getRole().getLibelle() : null);
        userData.put("isLocked", user.getIsLocked());
        userData.put("createdAt", convertToDate(user.getCreatedAt()));
        userData.put("updatedAt", convertToDate(user.getUpdatedAt()));
        userData.put("syncedAt", new Date());

        DocumentReference docRef = firestore.collection(COLLECTION_USERS).document(firebaseUid);
        ApiFuture<WriteResult> result = docRef.set(userData);
        result.get(); // Attendre la fin de l'opération

        // 3. Marquer comme synchronisé
        user.setFirebaseSynced(true);
        user.setSyncedAt(LocalDateTime.now());
        user.setFirebaseSyncError(null);
        userRepository.save(user);

        recordSyncSuccess(EntityType.USER, user.getId(), firebaseUid);
        log.info("User {} synchronisé avec succès vers Firebase", user.getId());
    }

    /**
     * Synchronise un signalement vers Firestore
     */
    @Transactional
    public void syncSignalementToFirebase(Signalement signalement) throws ExecutionException, InterruptedException {
        log.info("Synchronisation signalement {} vers Firebase", signalement.getId());
        Firestore firestore = FirestoreClient.getFirestore();

        Map<String, Object> data = new HashMap<>();
        data.put("id", signalement.getId());
        data.put("description", signalement.getDescription());
        data.put("adresse", signalement.getAdresse());
        data.put("latitude", signalement.getLatitude() != null ? signalement.getLatitude().doubleValue() : null);
        data.put("longitude", signalement.getLongitude() != null ? signalement.getLongitude().doubleValue() : null);
        data.put("photoUrl", signalement.getPhotoUrl());
        data.put("statusCode", signalement.getStatus() != null ? signalement.getStatus().getCode() : null);
        data.put("statusLibelle", signalement.getStatus() != null ? signalement.getStatus().getLibelle() : null);
        data.put("userEmail", signalement.getUser() != null ? signalement.getUser().getEmail() : null);
        data.put("userId", signalement.getUser() != null ? signalement.getUser().getId() : null);
        data.put("dateSignalement", convertToDate(signalement.getDateSignalement()));
        data.put("createdAt", convertToDate(signalement.getCreatedAt()));
        data.put("updatedAt", convertToDate(signalement.getUpdatedAt()));
        data.put("syncedAt", new Date());

        // Utiliser l'ID Firebase existant ou en générer un nouveau
        String docId = signalement.getFirebaseId() != null ?
                signalement.getFirebaseId() :
                String.valueOf(signalement.getId());

        DocumentReference docRef = firestore.collection(COLLECTION_SIGNALEMENTS).document(docId);
        ApiFuture<WriteResult> result = docRef.set(data);
        result.get();

        // Marquer comme synchronisé
        signalement.setFirebaseId(docId);
        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
        signalementRepository.save(signalement);

        recordSyncSuccess(EntityType.SIGNALEMENT, signalement.getId(), docId);
        log.info("Signalement {} synchronisé avec succès vers Firebase", signalement.getId());
    }

    /**
     * Synchronise une entreprise vers Firestore
     */
    @Transactional
    public void syncEntrepriseToFirebase(Entreprise entreprise) throws ExecutionException, InterruptedException {
        log.info("Synchronisation entreprise {} vers Firebase", entreprise.getId());
        Firestore firestore = FirestoreClient.getFirestore();

        Map<String, Object> data = new HashMap<>();
        data.put("id", entreprise.getId());
        data.put("nom", entreprise.getNom());
        data.put("siret", entreprise.getSiret());
        data.put("telephone", entreprise.getTelephone());
        data.put("email", entreprise.getEmail());
        data.put("adresse", entreprise.getAdresse());
        data.put("specialites", entreprise.getSpecialites() != null ?
                Arrays.asList(entreprise.getSpecialites()) : Collections.emptyList());
        data.put("isActive", entreprise.getIsActive());
        data.put("noteMoyenne", entreprise.getNoteMoyenne() != null ?
                entreprise.getNoteMoyenne().doubleValue() : null);
        data.put("nombreInterventions", entreprise.getNombreInterventions());
        data.put("createdAt", convertToDate(entreprise.getCreatedAt()));
        data.put("updatedAt", convertToDate(entreprise.getUpdatedAt()));
        data.put("syncedAt", new Date());

        String docId = String.valueOf(entreprise.getId());
        DocumentReference docRef = firestore.collection(COLLECTION_ENTREPRISES).document(docId);
        ApiFuture<WriteResult> result = docRef.set(data);
        result.get();

        log.info("Entreprise {} synchronisée avec succès vers Firebase", entreprise.getId());
    }

    /**
     * Synchronise un status vers Firestore
     */
    @Transactional
    public void syncStatusToFirebase(SignalementStatus status) throws ExecutionException, InterruptedException {
        log.info("Synchronisation status {} vers Firebase", status.getId());
        Firestore firestore = FirestoreClient.getFirestore();

        Map<String, Object> data = new HashMap<>();
        data.put("id", status.getId());
        data.put("code", status.getCode());
        data.put("libelle", status.getLibelle());
        data.put("description", status.getDescription());
        data.put("ordre", status.getOrdre());
        data.put("color", status.getCouleur());
        data.put("syncedAt", new Date());

        String docId = status.getCode();
        DocumentReference docRef = firestore.collection(COLLECTION_STATUS).document(docId);
        ApiFuture<WriteResult> result = docRef.set(data);
        result.get();

        log.info("Status {} synchronisé avec succès vers Firebase", status.getCode());
    }

    // ==================== FIREBASE → POSTGRES ====================

    /**
     * Synchronise toutes les entités de Firebase vers PostgreSQL
     */
    @Transactional
    public SyncResult syncFirebaseToPostgres() {
        SyncResult result = new SyncResult();

        try {
            // Synchroniser les utilisateurs
            result.addFirebaseToPostgres(syncUsersFromFirebase());

            // Synchroniser les signalements
            result.addFirebaseToPostgres(syncSignalementsFromFirebase());

            // Synchroniser les entreprises
            result.addFirebaseToPostgres(syncEntreprisesFromFirebase());

            result.setSuccess(true);
        } catch (Exception e) {
            log.error("Erreur globale sync Firebase → Postgres", e);
            result.setSuccess(false);
            result.setErrorMessage(e.getMessage());
        }

        return result;
    }

    /**
     * Synchronise les utilisateurs depuis Firebase vers PostgreSQL
     */
    @Transactional
    public SyncResult syncUsersFromFirebase() throws ExecutionException, InterruptedException {
        log.info("Synchronisation utilisateurs depuis Firebase");
        SyncResult result = new SyncResult();
        Firestore firestore = FirestoreClient.getFirestore();

        // Récupérer tous les documents de la collection users
        ApiFuture<QuerySnapshot> future = firestore.collection(COLLECTION_USERS).get();
        List<QueryDocumentSnapshot> documents = future.get().getDocuments();

        for (QueryDocumentSnapshot document : documents) {
            try {
                Map<String, Object> data = document.getData();
                String firebaseUid = document.getId();

                // Vérifier si l'utilisateur existe déjà
                Optional<User> existingUser = userRepository.findByFirebaseUid(firebaseUid);

                if (existingUser.isPresent()) {
                    // Mise à jour de l'utilisateur existant
                    User user = existingUser.get();
                    updateUserFromFirebaseData(user, data);
                    userRepository.save(user);
                    result.incrementSuccess("users_updated");
                    log.info("User mis à jour depuis Firebase: {}", firebaseUid);
                } else {
                    // Créer un nouvel utilisateur
                    // Note: On ne crée pas automatiquement un user depuis Firebase
                    // car il faut un mot de passe hashé et un rôle
                    log.warn("User Firebase trouvé mais pas dans PostgreSQL: {}", firebaseUid);
                    result.incrementError("users_not_found");
                }
            } catch (Exception e) {
                log.error("Erreur traitement user Firebase: {}", e.getMessage());
                result.incrementError("users");
            }
        }

        return result;
    }

    /**
     * Synchronise les signalements depuis Firebase vers PostgreSQL
     */
    @Transactional
    public SyncResult syncSignalementsFromFirebase() throws ExecutionException, InterruptedException {
        log.info("Synchronisation signalements depuis Firebase");
        SyncResult result = new SyncResult();
        Firestore firestore = FirestoreClient.getFirestore();

        ApiFuture<QuerySnapshot> future = firestore.collection(COLLECTION_SIGNALEMENTS).get();
        List<QueryDocumentSnapshot> documents = future.get().getDocuments();

        for (QueryDocumentSnapshot document : documents) {
            try {
                Map<String, Object> data = document.getData();
                String firebaseId = document.getId();

                // Chercher le signalement par firebaseId ou par id
                Signalement signalement = findSignalementByFirebaseId(firebaseId, data);

                if (signalement != null) {
                    // Mise à jour
                    updateSignalementFromFirebaseData(signalement, data);
                    signalementRepository.save(signalement);
                    result.incrementSuccess("signalements_updated");
                    log.info("Signalement mis à jour depuis Firebase: {}", firebaseId);
                } else {
                    // Créer un nouveau signalement
                    Signalement newSignalement = createSignalementFromFirebaseData(data, firebaseId);
                    if (newSignalement != null) {
                        signalementRepository.save(newSignalement);
                        result.incrementSuccess("signalements_created");
                        log.info("Nouveau signalement créé depuis Firebase: {}", firebaseId);
                    } else {
                        result.incrementError("signalements_invalid_data");
                    }
                }
            } catch (Exception e) {
                log.error("Erreur traitement signalement Firebase: {}", e.getMessage());
                result.incrementError("signalements");
            }
        }

        return result;
    }

    /**
     * Synchronise les entreprises depuis Firebase vers PostgreSQL
     */
    @Transactional
    public SyncResult syncEntreprisesFromFirebase() throws ExecutionException, InterruptedException {
        log.info("Synchronisation entreprises depuis Firebase");
        SyncResult result = new SyncResult();
        Firestore firestore = FirestoreClient.getFirestore();

        ApiFuture<QuerySnapshot> future = firestore.collection(COLLECTION_ENTREPRISES).get();
        List<QueryDocumentSnapshot> documents = future.get().getDocuments();

        for (QueryDocumentSnapshot document : documents) {
            try {
                Map<String, Object> data = document.getData();
                Integer id = data.get("id") != null ?
                        ((Long) data.get("id")).intValue() : null;

                if (id != null) {
                    Optional<Entreprise> existing = entrepriseRepository.findById(id);
                    if (existing.isPresent()) {
                        // Mise à jour
                        Entreprise entreprise = existing.get();
                        updateEntrepriseFromFirebaseData(entreprise, data);
                        entrepriseRepository.save(entreprise);
                        result.incrementSuccess("entreprises_updated");
                    } else {
                        // Créer nouvelle entreprise
                        Entreprise newEntreprise = createEntrepriseFromFirebaseData(data);
                        if (newEntreprise != null) {
                            entrepriseRepository.save(newEntreprise);
                            result.incrementSuccess("entreprises_created");
                        }
                    }
                }
            } catch (Exception e) {
                log.error("Erreur traitement entreprise Firebase: {}", e.getMessage());
                result.incrementError("entreprises");
            }
        }

        return result;
    }

    // ==================== MÉTHODES UTILITAIRES ====================

    private void updateUserFromFirebaseData(User user, Map<String, Object> data) {
        if (data.containsKey("name")) {
            user.setName((String) data.get("name"));
        }
        if (data.containsKey("email")) {
            user.setEmail((String) data.get("email"));
        }
        user.setFirebaseSynced(true);
        user.setSyncedAt(LocalDateTime.now());
    }

    private Signalement findSignalementByFirebaseId(String firebaseId, Map<String, Object> data) {
        // Chercher par firebaseId
        List<Signalement> byFirebaseId = signalementRepository.findAll().stream()
                .filter(s -> firebaseId.equals(s.getFirebaseId()))
                .collect(Collectors.toList());

        if (!byFirebaseId.isEmpty()) {
            return byFirebaseId.get(0);
        }

        // Chercher par ID PostgreSQL
        try {
            Long id = data.get("id") != null ? ((Number) data.get("id")).longValue() : null;
            if (id != null) {
                return signalementRepository.findById(id).orElse(null);
            }
        } catch (Exception e) {
            log.warn("Impossible de récupérer l'ID: {}", e.getMessage());
        }

        return null;
    }

    private void updateSignalementFromFirebaseData(Signalement signalement, Map<String, Object> data) {
        if (data.containsKey("description")) {
            signalement.setDescription((String) data.get("description"));
        }
        if (data.containsKey("adresse")) {
            signalement.setAdresse((String) data.get("adresse"));
        }
        if (data.containsKey("latitude")) {
            signalement.setLatitude(BigDecimal.valueOf((Double) data.get("latitude")));
        }
        if (data.containsKey("longitude")) {
            signalement.setLongitude(BigDecimal.valueOf((Double) data.get("longitude")));
        }
        if (data.containsKey("photoUrl")) {
            signalement.setPhotoUrl((String) data.get("photoUrl"));
        }
        if (data.containsKey("statusCode")) {
            String statusCode = (String) data.get("statusCode");
            signalementStatusRepository.findByCode(statusCode)
                    .ifPresent(signalement::setStatus);
        }

        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
    }

    private Signalement createSignalementFromFirebaseData(Map<String, Object> data, String firebaseId) {
        try {
            // Récupérer l'utilisateur
            Long userId = data.get("userId") != null ? ((Number) data.get("userId")).longValue() : null;
            if (userId == null) {
                log.error("UserId manquant pour le signalement Firebase: {}", firebaseId);
                return null;
            }

            User user = userRepository.findById(userId).orElse(null);
            if (user == null) {
                log.error("User introuvable pour le signalement Firebase: {}", firebaseId);
                return null;
            }

            // Récupérer le status
            String statusCode = data.get("statusCode") != null ? (String) data.get("statusCode") : "NOUVEAU";
            SignalementStatus status = signalementStatusRepository.findByCode(statusCode)
                    .orElse(signalementStatusRepository.findByCode("NOUVEAU").orElse(null));

            if (status == null) {
                log.error("Status introuvable pour le signalement Firebase: {}", firebaseId);
                return null;
            }

            // Créer le signalement
            Signalement signalement = Signalement.builder()
                    .description((String) data.get("description"))
                    .adresse((String) data.get("adresse"))
                    .latitude(data.get("latitude") != null ?
                            BigDecimal.valueOf((Double) data.get("latitude")) : null)
                    .longitude(data.get("longitude") != null ?
                            BigDecimal.valueOf((Double) data.get("longitude")) : null)
                    .photoUrl((String) data.get("photoUrl"))
                    .user(user)
                    .status(status)
                    .firebaseId(firebaseId)
                    .firebaseSynced(true)
                    .build();

            return signalement;
        } catch (Exception e) {
            log.error("Erreur création signalement depuis Firebase: {}", e.getMessage());
            return null;
        }
    }

    private void updateEntrepriseFromFirebaseData(Entreprise entreprise, Map<String, Object> data) {
        if (data.containsKey("nom")) {
            entreprise.setNom((String) data.get("nom"));
        }
        if (data.containsKey("telephone")) {
            entreprise.setTelephone((String) data.get("telephone"));
        }
        if (data.containsKey("email")) {
            entreprise.setEmail((String) data.get("email"));
        }
        if (data.containsKey("adresse")) {
            entreprise.setAdresse((String) data.get("adresse"));
        }
        if (data.containsKey("isActive")) {
            entreprise.setIsActive((Boolean) data.get("isActive"));
        }
        if (data.containsKey("specialites")) {
            @SuppressWarnings("unchecked")
            List<String> specialitesList = (List<String>) data.get("specialites");
            entreprise.setSpecialites(specialitesList.toArray(new String[0]));
        }
    }

    private Entreprise createEntrepriseFromFirebaseData(Map<String, Object> data) {
        try {
            Entreprise entreprise = Entreprise.builder()
                    .nom((String) data.get("nom"))
                    .siret((String) data.get("siret"))
                    .telephone((String) data.get("telephone"))
                    .email((String) data.get("email"))
                    .adresse((String) data.get("adresse"))
                    .isActive(data.get("isActive") != null ? (Boolean) data.get("isActive") : true)
                    .build();

            if (data.containsKey("specialites")) {
                @SuppressWarnings("unchecked")
                List<String> specialitesList = (List<String>) data.get("specialites");
                entreprise.setSpecialites(specialitesList.toArray(new String[0]));
            }

            return entreprise;
        } catch (Exception e) {
            log.error("Erreur création entreprise depuis Firebase: {}", e.getMessage());
            return null;
        }
    }

    // ==================== GESTION DES ERREURS ET HISTORIQUE ====================

    private void recordSyncSuccess(EntityType entityType, Long entityId, String firebaseId) {
        Map<String, Object> firebaseResponse = new HashMap<>();
        firebaseResponse.put("firebaseId", firebaseId);
        firebaseResponse.put("status", "success");

        SyncHistory history = SyncHistory.builder()
                .entityType(entityType)
                .entityId(entityId)
                .action(SyncAction.UPDATE)
                .direction(SyncDirection.POSTGRES_TO_FIREBASE)
                .status(SyncStatus.SUCCESS)
                .firebaseResponse(firebaseResponse)
                .syncedAt(LocalDateTime.now())
                .build();
        syncHistoryRepository.save(history);
    }

    private void recordSyncError(EntityType entityType, Long entityId, String errorMessage) {
        SyncHistory history = SyncHistory.builder()
                .entityType(entityType)
                .entityId(entityId)
                .action(SyncAction.UPDATE)
                .direction(SyncDirection.POSTGRES_TO_FIREBASE)
                .status(SyncStatus.FAILED)
                .errorMessage(errorMessage)
                .syncedAt(LocalDateTime.now())
                .build();
        syncHistoryRepository.save(history);
    }

    // ==================== HELPERS ====================

    private Date convertToDate(LocalDateTime localDateTime) {
        if (localDateTime == null) return null;
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }

    private LocalDateTime convertToLocalDateTime(Date date) {
        if (date == null) return null;
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }

    private String generateTemporaryPassword() {
        return UUID.randomUUID().toString().substring(0, 16);
    }

    // ==================== CLASSE RÉSULTAT ====================

    @lombok.Data
    public static class SyncResult {
        private boolean success;
        private String errorMessage;
        private Map<String, Integer> successCounts = new HashMap<>();
        private Map<String, Integer> errorCounts = new HashMap<>();

        public void incrementSuccess(String category) {
            successCounts.put(category, successCounts.getOrDefault(category, 0) + 1);
        }

        public void incrementError(String category) {
            errorCounts.put(category, errorCounts.getOrDefault(category, 0) + 1);
        }

        public void addPostgresToFirebase(SyncResult other) {
            other.successCounts.forEach((key, value) ->
                    successCounts.merge("pg_to_fb_" + key, value, Integer::sum));
            other.errorCounts.forEach((key, value) ->
                    errorCounts.merge("pg_to_fb_" + key, value, Integer::sum));
        }

        public void addFirebaseToPostgres(SyncResult other) {
            other.successCounts.forEach((key, value) ->
                    successCounts.merge("fb_to_pg_" + key, value, Integer::sum));
            other.errorCounts.forEach((key, value) ->
                    errorCounts.merge("fb_to_pg_" + key, value, Integer::sum));
        }

        public int getTotalSuccess() {
            return successCounts.values().stream().mapToInt(Integer::intValue).sum();
        }

        public int getTotalErrors() {
            return errorCounts.values().stream().mapToInt(Integer::intValue).sum();
        }
    }
}



============================================================
FILE: HistoriqueStatusService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.HistoriqueStatus;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.HistoriqueStatusRepository;
import mg.projetfinal.repository.SignalementRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class HistoriqueStatusService {

    private final HistoriqueStatusRepository historiqueStatusRepository;
    private final SignalementRepository signalementRepository;

    public HistoriqueStatus create(HistoriqueStatus historique) {
        log.info("Création d'un nouvel historique de statut");
        
        if (historique.getSignalement() == null) {
            throw new IllegalArgumentException("Le signalement est obligatoire");
        }
        
        if (historique.getAncienStatus() == null || historique.getNouveauStatus() == null) {
            throw new IllegalArgumentException("L'ancien et le nouveau statut sont obligatoires");
        }
        
        if (historique.getModifiedBy() == null) {
            throw new IllegalArgumentException("L'utilisateur qui a modifié le statut est obligatoire");
        }
        
        return historiqueStatusRepository.save(historique);
    }

    @Transactional(readOnly = true)
    public Optional<HistoriqueStatus> findById(Long id) {
        log.debug("Recherche de l'historique avec l'ID: {}", id);
        return historiqueStatusRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findAll() {
        log.debug("Récupération de tous les historiques");
        return historiqueStatusRepository.findAll();
    }

    public void delete(Long id) {
        log.info("Suppression de l'historique avec l'ID: {}", id);
        
        if (!historiqueStatusRepository.existsById(id)) {
            throw new IllegalArgumentException("Historique non trouvé avec l'ID: " + id);
        }
        
        historiqueStatusRepository.deleteById(id);
    }

    public HistoriqueStatus createHistorique(
            Signalement signalement,
            SignalementStatus ancienStatus,
            SignalementStatus nouveauStatus,
            User modifiedBy,
            String commentaire) {
        
        return createHistorique(signalement, ancienStatus, nouveauStatus, modifiedBy, commentaire, null);
    }

    public HistoriqueStatus createHistorique(
            Signalement signalement,
            SignalementStatus ancienStatus,
            SignalementStatus nouveauStatus,
            User modifiedBy,
            String commentaire,
            Map<String, Object> metadata) {
        
        log.info("Création d'un historique de changement de statut pour le signalement ID: {}", signalement.getId());
        
        HistoriqueStatus historique = HistoriqueStatus.builder()
                .signalement(signalement)
                .ancienStatus(ancienStatus)
                .nouveauStatus(nouveauStatus)
                .modifiedBy(modifiedBy)
                .commentaire(commentaire)
                .metadata(metadata)
                .build();
        
        HistoriqueStatus savedHistorique = historiqueStatusRepository.save(historique);
        
        signalement.addHistorique(savedHistorique);
        
        return savedHistorique;
    }

    public HistoriqueStatus createInitialHistorique(Signalement signalement, User createdBy) {
        log.info("Création de l'historique initial pour le signalement ID: {}", signalement.getId());
        
        SignalementStatus initialStatus = signalement.getStatus();
        
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("initial", true);
        metadata.put("createdAt", signalement.getCreatedAt());
        
        HistoriqueStatus historique = HistoriqueStatus.builder()
                .signalement(signalement)
                .ancienStatus(initialStatus)
                .nouveauStatus(initialStatus)
                .modifiedBy(createdBy)
                .commentaire("Création du signalement")
                .metadata(metadata)
                .build();
        
        HistoriqueStatus savedHistorique = historiqueStatusRepository.save(historique);
        
        signalement.addHistorique(savedHistorique);
        
        return savedHistorique;
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findBySignalement(Signalement signalement) {
        log.debug("Recherche des historiques pour le signalement ID: {}", signalement.getId());
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findBySignalementOrderByDate(Signalement signalement) {
        log.debug("Recherche des historiques triés par date pour le signalement ID: {}", signalement.getId());
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findByUser(User user) {
        log.debug("Recherche des historiques pour l'utilisateur ID: {}", user.getId());
        
        return historiqueStatusRepository.findAll().stream()
                .filter(h -> h.getModifiedBy().equals(user))
                .toList();
    }

    @Transactional(readOnly = true)
    public HistoriqueStatus getLastStatusChange(Signalement signalement) {
        log.debug("Récupération du dernier changement de statut pour le signalement ID: {}", signalement.getId());
        
        List<HistoriqueStatus> historiques = historiqueStatusRepository
                .findBySignalementOrderByChangedAtDesc(signalement);
        
        return historiques.isEmpty() ? null : historiques.get(0);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> getStatusHistory(Long signalementId) {
        log.debug("Récupération de l'historique complet pour le signalement ID: {}", signalementId);
        
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + signalementId));
        
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public long countStatusChangesByUser(User user) {
        log.debug("Comptage des changements de statut effectués par l'utilisateur ID: {}", user.getId());
        
        return historiqueStatusRepository.findAll().stream()
                .filter(h -> h.getModifiedBy().equals(user))
                .count();
    }
}



============================================================
FILE: PhotoSignalementService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.PhotoSignalement;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.PhotoSignalementRepository;
import mg.projetfinal.repository.SignalementRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class PhotoSignalementService {

    private final PhotoSignalementRepository photoRepository;
    private final SignalementRepository signalementRepository;

    @Transactional
    public PhotoSignalement addPhoto(Long signalementId, String url, String description, User uploadedBy) {
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new RuntimeException("Signalement introuvable"));

        Long count = photoRepository.countBySignalement(signalement);

        PhotoSignalement photo = PhotoSignalement.builder()
                .signalement(signalement)
                .url(url)
                .description(description)
                .ordre(count.intValue() + 1)
                .isPrincipale(count == 0) // Première photo = principale
                .uploadedBy(uploadedBy)
                .build();

        return photoRepository.save(photo);
    }

    @Transactional
    public PhotoSignalement setPrincipale(Long photoId) {
        PhotoSignalement photo = photoRepository.findById(photoId)
                .orElseThrow(() -> new RuntimeException("Photo introuvable"));

        // Retirer l'ancienne photo principale
        photoRepository.findBySignalementAndIsPrincipaleTrue(photo.getSignalement())
                .ifPresent(ancienne -> {
                    ancienne.setIsPrincipale(false);
                    photoRepository.save(ancienne);
                });

        // Définir la nouvelle
        photo.setIsPrincipale(true);
        return photoRepository.save(photo);
    }

    public List<PhotoSignalement> getPhotosBySignalement(Long signalementId) {
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new RuntimeException("Signalement introuvable"));
        return photoRepository.findBySignalementOrderByOrdreAsc(signalement);
    }

    public PhotoSignalement getPhotoPrincipale(Long signalementId) {
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new RuntimeException("Signalement introuvable"));
        return photoRepository.findBySignalementAndIsPrincipaleTrue(signalement)
                .orElse(null);
    }

    @Transactional
    public void deletePhoto(Long photoId) {
        PhotoSignalement photo = photoRepository.findById(photoId)
                .orElseThrow(() -> new RuntimeException("Photo introuvable"));

        boolean wasPrincipale = photo.getIsPrincipale();
        Signalement signalement = photo.getSignalement();

        photoRepository.delete(photo);

        // Si c'était la photo principale, définir une nouvelle
        if (wasPrincipale) {
            List<PhotoSignalement> remaining = photoRepository.findBySignalementOrderByOrdreAsc(signalement);
            if (!remaining.isEmpty()) {
                PhotoSignalement newPrincipale = remaining.get(0);
                newPrincipale.setIsPrincipale(true);
                photoRepository.save(newPrincipale);
            }
        }
    }

    @Transactional
    public void reorderPhotos(Long signalementId, List<Long> photoIds) {
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new RuntimeException("Signalement introuvable"));

        for (int i = 0; i < photoIds.size(); i++) {
            Long photoId = photoIds.get(i);
            PhotoSignalement photo = photoRepository.findById(photoId)
                    .orElseThrow(() -> new RuntimeException("Photo " + photoId + " introuvable"));

            // Vérifier que la photo appartient bien à ce signalement
            if (!photo.getSignalement().getId().equals(signalementId)) {
                throw new RuntimeException("La photo " + photoId + " n'appartient pas au signalement " + signalementId);
            }

            photo.setOrdre(i + 1);
            photoRepository.save(photo);
        }
    }
}



============================================================
FILE: SignalementActionService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.SignalementAction;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.SignalementActionRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class SignalementActionService {

    private final SignalementActionRepository signalementActionRepository;
    private final EntrepriseService entrepriseService;

    public SignalementAction create(SignalementAction action, User createdBy) {
        log.info("Création d'une nouvelle action pour le signalement ID: {}", action.getSignalement().getId());
        
        if (action.getSignalement() == null) {
            throw new IllegalArgumentException("Le signalement est obligatoire");
        }
        
        if (action.getDescriptionTravaux() == null || action.getDescriptionTravaux().trim().isEmpty()) {
            throw new IllegalArgumentException("La description des travaux est obligatoire");
        }
        
        action.setCreatedBy(createdBy);
        
        SignalementAction savedAction = signalementActionRepository.save(action);
        
        // Incrémenter le nombre d'interventions de l'entreprise si elle est assignée
        if (action.getEntreprise() != null) {
            entrepriseService.incrementInterventions(action.getEntreprise().getId());
        }
        
        return savedAction;
    }

    public SignalementAction update(Long id, SignalementAction action, User modifiedBy) {
        log.info("Mise à jour de l'action avec l'ID: {}", id);
        
        SignalementAction existingAction = signalementActionRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + id));
        
        existingAction.setDescriptionTravaux(action.getDescriptionTravaux());
        existingAction.setMaterielUtilise(action.getMaterielUtilise());
        existingAction.setSurfaceM2(action.getSurfaceM2());
        existingAction.setBudget(action.getBudget());
        existingAction.setDateDebutTravaux(action.getDateDebutTravaux());
        existingAction.setDateFinPrevue(action.getDateFinPrevue());
        existingAction.setPhotosAvant(action.getPhotosAvant());
        existingAction.setPhotosApres(action.getPhotosApres());
        existingAction.setModifiedBy(modifiedBy);
        
        // Si l'entreprise change, mettre à jour les compteurs
        if (action.getEntreprise() != null && 
                !action.getEntreprise().equals(existingAction.getEntreprise())) {
            existingAction.setEntreprise(action.getEntreprise());
            entrepriseService.incrementInterventions(action.getEntreprise().getId());
        }
        
        return signalementActionRepository.save(existingAction);
    }

    @Transactional(readOnly = true)
    public Optional<SignalementAction> findById(Long id) {
        log.debug("Recherche de l'action avec l'ID: {}", id);
        return signalementActionRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findAll() {
        log.debug("Récupération de toutes les actions");
        return signalementActionRepository.findAll();
    }

    public void delete(Long id) {
        log.info("Suppression de l'action avec l'ID: {}", id);
        
        if (!signalementActionRepository.existsById(id)) {
            throw new IllegalArgumentException("Action non trouvée avec l'ID: " + id);
        }
        
        signalementActionRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findBySignalement(Signalement signalement) {
        log.debug("Recherche des actions pour le signalement ID: {}", signalement.getId());
        return signalementActionRepository.findBySignalement(signalement);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findByEntreprise(Entreprise entreprise) {
        log.debug("Recherche des actions pour l'entreprise ID: {}", entreprise.getId());
        return signalementActionRepository.findByEntreprise(entreprise);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsEnCours() {
        log.debug("Récupération des actions en cours");
        return signalementActionRepository.findActionsEnCours();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsEnRetard() {
        log.debug("Récupération des actions en retard");
        return signalementActionRepository.findActionsEnRetard();
    }

    public SignalementAction assignerEntreprise(Long actionId, Entreprise entreprise, User modifiedBy) {
        log.info("Assignation de l'entreprise ID: {} à l'action ID: {}", entreprise.getId(), actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getEntreprise() != null) {
            log.warn("L'action possède déjà une entreprise assignée");
        }
        
        action.setEntreprise(entreprise);
        action.setModifiedBy(modifiedBy);
        
        entrepriseService.incrementInterventions(entreprise.getId());
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction demarrerTravaux(Long actionId, LocalDateTime dateDebut, User modifiedBy) {
        log.info("Démarrage des travaux pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateDebutTravaux() != null) {
            throw new IllegalStateException("Les travaux ont déjà démarré");
        }
        
        if (action.getEntreprise() == null) {
            throw new IllegalStateException("Une entreprise doit être assignée avant de démarrer les travaux");
        }
        
        action.setDateDebutTravaux(dateDebut != null ? dateDebut : LocalDateTime.now());
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction terminerTravaux(Long actionId, boolean conformes, String commentaire, User modifiedBy) {
        log.info("Fin des travaux pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateDebutTravaux() == null) {
            throw new IllegalStateException("Les travaux n'ont pas encore démarré");
        }
        
        if (action.getDateFinReelle() != null) {
            throw new IllegalStateException("Les travaux sont déjà terminés");
        }
        
        action.terminerTravaux(conformes, commentaire);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction ajouterPhotosAvant(Long actionId, String[] photos, User modifiedBy) {
        log.info("Ajout de {} photos avant pour l'action ID: {}", photos.length, actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        action.setPhotosAvant(photos);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction ajouterPhotosApres(Long actionId, String[] photos, User modifiedBy) {
        log.info("Ajout de {} photos après pour l'action ID: {}", photos.length, actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateFinReelle() == null) {
            log.warn("Les travaux ne sont pas encore terminés");
        }
        
        action.setPhotosApres(photos);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction updateBudget(Long actionId, BigDecimal budget, User modifiedBy) {
        log.info("Mise à jour du budget pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (budget == null || budget.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Le budget doit être positif");
        }
        
        action.setBudget(budget);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction updateDateFinPrevue(Long actionId, LocalDateTime dateFinPrevue, User modifiedBy) {
        log.info("Mise à jour de la date de fin prévue pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (dateFinPrevue != null && action.getDateDebutTravaux() != null 
                && dateFinPrevue.isBefore(action.getDateDebutTravaux())) {
            throw new IllegalArgumentException("La date de fin prévue ne peut pas être avant la date de début");
        }
        
        action.setDateFinPrevue(dateFinPrevue);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    @Transactional(readOnly = true)
    public long countActionsEnCours() {
        return signalementActionRepository.findActionsEnCours().size();
    }

    @Transactional(readOnly = true)
    public long countActionsEnRetard() {
        return signalementActionRepository.findActionsEnRetard().size();
    }

    @Transactional(readOnly = true)
    public long countActionsByEntreprise(Entreprise entreprise) {
        return signalementActionRepository.findByEntreprise(entreprise).size();
    }

    @Transactional(readOnly = true)
    public long countActionsTerminees() {
        return signalementActionRepository.findAll().stream()
                .filter(SignalementAction::isTermine)
                .count();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsConformes() {
        log.debug("Récupération des actions conformes");
        return signalementActionRepository.findAll().stream()
                .filter(action -> action.getTravauxConformes() != null && action.getTravauxConformes())
                .toList();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsNonConformes() {
        log.debug("Récupération des actions non conformes");
        return signalementActionRepository.findAll().stream()
                .filter(action -> action.getTravauxConformes() != null && !action.getTravauxConformes())
                .toList();
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateBudgetTotal() {
        log.debug("Calcul du budget total de toutes les actions");
        return signalementActionRepository.findAll().stream()
                .map(SignalementAction::getBudget)
                .filter(budget -> budget != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateBudgetByEntreprise(Entreprise entreprise) {
        log.debug("Calcul du budget total pour l'entreprise ID: {}", entreprise.getId());
        return signalementActionRepository.findByEntreprise(entreprise).stream()
                .map(SignalementAction::getBudget)
                .filter(budget -> budget != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}



============================================================
FILE: SignalementService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.SignalementRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class SignalementService {

    private final SignalementRepository signalementRepository;
    private final HistoriqueStatusService historiqueStatusService;

    public Signalement create(Signalement signalement, User user) {
        log.info("Création d'un nouveau signalement pour l'utilisateur: {}", user.getId());
        
        if (signalement.getLatitude() == null || signalement.getLongitude() == null) {
            throw new IllegalArgumentException("La localisation (latitude et longitude) est obligatoire");
        }
        
        if (signalement.getDescription() == null || signalement.getDescription().trim().isEmpty()) {
            throw new IllegalArgumentException("La description est obligatoire");
        }
        
        signalement.setUser(user);
        signalement.setFirebaseSynced(false);
        
        Signalement savedSignalement = signalementRepository.save(signalement);
        
        if (signalement.getStatus() != null) {
            historiqueStatusService.createInitialHistorique(savedSignalement, user);
        }
        
        return savedSignalement;
    }

    public Signalement update(Long id, Signalement signalement) {
        log.info("Mise à jour du signalement avec l'ID: {}", id);
        
        Signalement existingSignalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        existingSignalement.setDescription(signalement.getDescription());
        existingSignalement.setAdresse(signalement.getAdresse());
        existingSignalement.setPhotoUrl(signalement.getPhotoUrl());
        
        if (!existingSignalement.getLatitude().equals(signalement.getLatitude()) 
                || !existingSignalement.getLongitude().equals(signalement.getLongitude())) {
            existingSignalement.setLatitude(signalement.getLatitude());
            existingSignalement.setLongitude(signalement.getLongitude());
            existingSignalement.setFirebaseSynced(false);
        }
        
        return signalementRepository.save(existingSignalement);
    }

    @Transactional(readOnly = true)
    public Optional<Signalement> findById(Long id) {
        log.debug("Recherche du signalement avec l'ID: {}", id);
        return signalementRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findAll() {
        log.debug("Récupération de tous les signalements");
        return signalementRepository.findAll();
    }

    @Transactional(readOnly = true)
    public List<Signalement> findAllOrderByDateDesc() {
        log.debug("Récupération de tous les signalements triés par date");
        return signalementRepository.findAllOrderByDateDesc();
    }

    public void delete(Long id) {
        log.info("Suppression du signalement avec l'ID: {}", id);
        
        if (!signalementRepository.existsById(id)) {
            throw new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id);
        }
        
        signalementRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByUser(User user) {
        log.debug("Recherche des signalements pour l'utilisateur: {}", user.getId());
        return signalementRepository.findByUser(user);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByStatus(SignalementStatus status) {
        log.debug("Recherche des signalements par statut: {}", status.getCode());
        return signalementRepository.findByStatus(status);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByStatusCode(String statusCode) {
        log.debug("Recherche des signalements par code de statut: {}", statusCode);
        return signalementRepository.findByStatusCode(statusCode);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findNonSyncedWithFirebase() {
        log.debug("Récupération des signalements non synchronisés avec Firebase");
        return signalementRepository.findByFirebaseSyncedFalse();
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByLocation(BigDecimal latitude, BigDecimal longitude, double radiusKm) {
        log.debug("Recherche des signalements dans un rayon de {} km autour de ({}, {})", 
                radiusKm, latitude, longitude);
        
        return signalementRepository.findAll().stream()
                .filter(signalement -> {
                    double distance = calculateDistance(
                            latitude.doubleValue(), 
                            longitude.doubleValue(),
                            signalement.getLatitude().doubleValue(),
                            signalement.getLongitude().doubleValue()
                    );
                    return distance <= radiusKm;
                })
                .collect(Collectors.toList());
    }

    public Signalement changeStatus(Long id, SignalementStatus newStatus, User modifiedBy, String commentaire) {
        log.info("Changement de statut pour le signalement ID: {} vers {}", id, newStatus.getCode());
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        SignalementStatus oldStatus = signalement.getStatus();
        
        if (oldStatus.equals(newStatus)) {
            log.warn("Le signalement est déjà au statut: {}", newStatus.getCode());
            return signalement;
        }
        
        historiqueStatusService.createHistorique(signalement, oldStatus, newStatus, modifiedBy, commentaire);
        
        signalement.setStatus(newStatus);
        signalement.setFirebaseSynced(false);
        
        return signalementRepository.save(signalement);
    }

    public void markAsSynced(Long id, String firebaseId) {
        log.info("Marquage du signalement ID: {} comme synchronisé avec Firebase ID: {}", id, firebaseId);
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        signalement.setFirebaseId(firebaseId);
        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
        
        signalementRepository.save(signalement);
    }

    public void syncWithFirebase(Long id) {
        log.info("Synchronisation du signalement ID: {} avec Firebase", id);
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        // TODO: Implémenter la logique de synchronisation avec Firebase
        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
        
        signalementRepository.save(signalement);
    }

    public List<Signalement> syncAllPending() {
        log.info("Synchronisation de tous les signalements en attente avec Firebase");
        
        List<Signalement> pendingSignalements = findNonSyncedWithFirebase();
        
        for (Signalement signalement : pendingSignalements) {
            try {
                syncWithFirebase(signalement.getId());
            } catch (Exception e) {
                log.error("Erreur lors de la synchronisation du signalement ID: {}", signalement.getId(), e);
            }
        }
        
        return pendingSignalements;
    }

    @Transactional(readOnly = true)
    public long countByStatus(SignalementStatus status) {
        return signalementRepository.findByStatus(status).size();
    }

    @Transactional(readOnly = true)
    public long countByUser(User user) {
        return signalementRepository.findByUser(user).size();
    }

    @Transactional(readOnly = true)
    public long countNouveau() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isNouveau)
                .count();
    }

    @Transactional(readOnly = true)
    public long countEnCours() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isEnCours)
                .count();
    }

    @Transactional(readOnly = true)
    public long countTermine() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isTermine)
                .count();
    }

    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        final int EARTH_RADIUS = 6371;
        
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                   Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                   Math.sin(dLon / 2) * Math.sin(dLon / 2);
        
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return EARTH_RADIUS * c;
    }
}



============================================================
FILE: SignalementStatusService.java
PACKAGE: mg.projetfinal.service
============================================================

// SignalementStatusService.java
package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.repository.SignalementStatusRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * Service pour la gestion des statuts de signalements
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class SignalementStatusService {

    private final SignalementStatusRepository statusRepository;

    /**
     * Récupère tous les statuts ordonnés par ordre
     */
    public List<SignalementStatus> findAllOrderByOrdre() {
        log.debug("Récupération de tous les statuts ordonnés");
        return statusRepository.findAllByOrderByOrdreAsc();
    }

    /**
     * Récupère tous les statuts
     */
    public List<SignalementStatus> findAll() {
        log.debug("Récupération de tous les statuts");
        return statusRepository.findAll();
    }

    /**
     * Récupère un statut par ID
     */
    public Optional<SignalementStatus> findById(Integer id) {
        log.debug("Récupération du statut avec ID: {}", id);
        return statusRepository.findById(id);
    }

    /**
     * Récupère un statut par code
     */
    public Optional<SignalementStatus> findByCode(String code) {
        log.debug("Récupération du statut avec code: {}", code);
        return statusRepository.findByCode(code);
    }

    /**
     * Vérifie si un statut existe par code
     */
    public boolean existsByCode(String code) {
        return statusRepository.existsByCode(code);
    }

    /**
     * Crée un nouveau statut
     */
    public SignalementStatus create(SignalementStatus status) {
        log.info("Création d'un nouveau statut: {}", status.getCode());

        if (existsByCode(status.getCode())) {
            throw new RuntimeException("Un statut avec ce code existe déjà");
        }

        return statusRepository.save(status);
    }

    /**
     * Met à jour un statut
     */
    public SignalementStatus update(Integer id, SignalementStatus statusDetails) {
        log.info("Mise à jour du statut ID: {}", id);

        SignalementStatus status = findById(id)
                .orElseThrow(() -> new RuntimeException("Statut non trouvé"));

        status.setLibelle(statusDetails.getLibelle());
        status.setDescription(statusDetails.getDescription());
        status.setOrdre(statusDetails.getOrdre());
        status.setCouleur(statusDetails.getCouleur());

        return statusRepository.save(status);
    }

    /**
     * Supprime un statut
     */
    public void delete(Integer id) {
        log.info("Suppression du statut ID: {}", id);

        SignalementStatus status = findById(id)
                .orElseThrow(() -> new RuntimeException("Statut non trouvé"));

        statusRepository.delete(status);
    }

    /**
     * Récupère le statut par défaut (généralement "nouveau")
     */
    public SignalementStatus getDefaultStatus() {
        return findByCode("nouveau")
                .orElseGet(() -> findAllOrderByOrdre().stream()
                        .findFirst()
                        .orElseThrow(() -> new RuntimeException("Aucun statut disponible")));
    }
}



============================================================
FILE: UserService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import mg.projetfinal.entity.User;
import mg.projetfinal.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> findAll() {
        return userRepository.findAll();
    }

}



