============================================================
FILE: AuthService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseAuthException;
import com.google.firebase.auth.UserRecord;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.*;
import mg.projetfinal.enums.FailureReason;
import mg.projetfinal.repository.*;
import mg.projetfinal.utils.NetworkUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final SessionRepository sessionRepository;
    private final LoginAttemptRepository loginAttemptRepository;
    private final FailedLoginTrackingRepository failedLoginTrackingRepository;
    private final PasswordEncoder passwordEncoder;

    @Value("${auth.max-attempts:3}")
    private int maxAttempts;

    @Value("${session.expiry-minutes:30}")
    private int sessionExpiryMinutes;

    @Value("${auth.lockout-duration-minutes:30}")
    private int lockoutDurationMinutes;

    @Value("${app.mode:online}")
    private String appMode;

    // ==================== INSCRIPTION ====================

    @Transactional
    public User register(String email, String password, String name, User createdBy) {
        // Vérifier si email existe déjà
        if (userRepository.existsByEmail(email)) {
            throw new RuntimeException("Email déjà utilisé");
        }

        // Récupérer le rôle par défaut (UTILISATEUR)
        Role defaultRole = roleRepository.findByCode("UTILISATEUR")
                .orElseThrow(() -> new RuntimeException("Rôle UTILISATEUR introuvable"));

        // Créer l'utilisateur
        User user = User.builder()
                .email(email)
                .passwordHash(passwordEncoder.encode(password))
                .name(name)
                .role(defaultRole)
                .firebaseSynced(false)
                .isLocked(false)
                .failedAttempts(0)
                .createdBy(createdBy)
                .build();

        // Synchronisation Firebase si mode online
        if (isOnline()) {
            try {
                UserRecord.CreateRequest request = new UserRecord.CreateRequest()
                        .setEmail(email)
                        .setPassword(password)
                        .setDisplayName(name);

                UserRecord firebaseUser = FirebaseAuth.getInstance().createUser(request);
                user.setFirebaseUid(firebaseUser.getUid());
                user.setFirebaseSynced(true);
                user.setSyncedAt(LocalDateTime.now());

                log.info("User créé dans Firebase: {}", firebaseUser.getUid());
            } catch (FirebaseAuthException e) {
                user.setFirebaseSyncError(e.getMessage());
                log.error("Erreur création Firebase: {}", e.getMessage());
            }
        }

        return userRepository.save(user);
    }

    // ==================== CONNEXION ====================

    @Transactional
    public Session login(String email, String password, HttpServletRequest request) {
        String ipAddress = getClientIp(request);
        String userAgent = request.getHeader("User-Agent");

        // Étape 1: Vérifier blocage dans failed_login_tracking
        Optional<FailedLoginTracking> trackingOpt = failedLoginTrackingRepository.findByEmail(email);
        if (trackingOpt.isPresent()) {
            FailedLoginTracking tracking = trackingOpt.get();
            if (tracking.isCurrentlyBlocked()) {
                recordLoginAttempt(email, null, false, FailureReason.ACCOUNT_LOCKED, ipAddress, userAgent);
                throw new RuntimeException("Compte bloqué jusqu'à " + tracking.getBlockedUntil());
            }
        }

        // Étape 2: Chercher l'utilisateur
        Optional<User> userOpt = userRepository.findByEmail(email);
        if (userOpt.isEmpty()) {
            recordLoginAttempt(email, null, false, FailureReason.USER_NOT_FOUND, ipAddress, userAgent);
            throw new RuntimeException("Email ou mot de passe incorrect");
        }

        User user = userOpt.get();

        // Étape 3: Vérifier blocage dans users
        if (user.isAccountLocked()) {
            recordLoginAttempt(email, user, false, FailureReason.ACCOUNT_LOCKED, ipAddress, userAgent);
            throw new RuntimeException("Compte verrouillé jusqu'à " + user.getLockedUntil());
        }

        // Étape 4: Vérifier le mot de passe
        if (!passwordEncoder.matches(password, user.getPasswordHash())) {
            recordLoginAttempt(email, user, false, FailureReason.INVALID_PASSWORD, ipAddress, userAgent);

            // Récupérer le tracking pour connaître le nombre de tentatives
            FailedLoginTracking tracking = trackingOpt.orElse(
                    FailedLoginTracking.builder()
                            .email(email)
                            .failedCount(0)
                            .isBlocked(false)
                            .build()
            );

            // Incrémenter et sauvegarder AVANT de vérifier
            tracking.recordFailedAttempt();
            failedLoginTrackingRepository.save(tracking);

            int remainingAttempts = maxAttempts - tracking.getFailedCount();

            // Bloquer si limite atteinte
            if (tracking.getFailedCount() >= maxAttempts) {
                tracking.blockAccount(lockoutDurationMinutes,
                        "Trop de tentatives de connexion échouées (" + maxAttempts + ")");
                failedLoginTrackingRepository.save(tracking);

                user.lockAccount(lockoutDurationMinutes);
                userRepository.save(user);

                log.warn("Compte bloqué pour {}: {} tentatives échouées", email, tracking.getFailedCount());
                throw new RuntimeException("Compte bloqué pour " + lockoutDurationMinutes + " minutes suite à trop de tentatives échouées");
            }

            // Sinon informer du nombre de tentatives restantes
            throw new RuntimeException("Email ou mot de passe incorrect. Tentatives restantes: " + remainingAttempts);
        }

        // Étape 5: Vérifier si déjà connecté
        List<Session> activeSessions = sessionRepository.findByUserAndIsActiveTrue(user);
        for (Session activeSession : activeSessions) {
            if (activeSession.isValid()) {
                throw new RuntimeException("Utilisateur déjà connecté. Veuillez vous déconnecter d'abord ou utiliser /logout-all");
            }
        }

        // Étape 6: Vérifier Firebase si online
        if (isOnline()) {
            try {
                FirebaseAuth.getInstance().getUserByEmail(email);
            } catch (FirebaseAuthException e) {
                recordLoginAttempt(email, user, false, FailureReason.FIREBASE_ERROR, ipAddress, userAgent);
                log.error("Erreur Firebase lors du login: {}", e.getMessage());
                throw new RuntimeException("Erreur de synchronisation Firebase");
            }
        }

        // Étape 7: Connexion réussie - Reset des tentatives échouées
        recordLoginAttempt(email, user, true, null, ipAddress, userAgent);

        // Reset tracking
        if (trackingOpt.isPresent()) {
            FailedLoginTracking tracking = trackingOpt.get();
            tracking.reset();
            failedLoginTrackingRepository.save(tracking);
        }

        // Reset user
        user.resetFailedAttempts();
        userRepository.save(user);

        // Créer une session
        return createSession(user, ipAddress, userAgent);
    }

    // ==================== MODIFICATION USER ====================

    @Transactional
    public User updateUser(Long userId, String name, String password, User modifiedBy) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur introuvable"));

        // Vérifier les permissions (seul le user lui-même ou un manager peut modifier)
        if (!modifiedBy.getId().equals(userId) && !modifiedBy.isManager()) {
            throw new RuntimeException("Permission refusée");
        }

        // Mettre à jour les infos
        if (name != null && !name.isEmpty()) {
            user.setName(name);
        }

        if (password != null && !password.isEmpty()) {
            user.setPasswordHash(passwordEncoder.encode(password));
        }

        // Synchroniser avec Firebase si online
        if (isOnline() && user.getFirebaseUid() != null) {
            try {
                UserRecord.UpdateRequest request = new UserRecord.UpdateRequest(user.getFirebaseUid());

                if (name != null && !name.isEmpty()) {
                    request.setDisplayName(name);
                }
                if (password != null && !password.isEmpty()) {
                    request.setPassword(password);
                }

                FirebaseAuth.getInstance().updateUser(request);
                user.setFirebaseSynced(true);
                user.setSyncedAt(LocalDateTime.now());
                user.setFirebaseSyncError(null);

                log.info("User mis à jour dans Firebase: {}", user.getFirebaseUid());
            } catch (FirebaseAuthException e) {
                user.setFirebaseSynced(false);
                user.setFirebaseSyncError(e.getMessage());
                log.error("Erreur mise à jour Firebase: {}", e.getMessage());
            }
        }

        return userRepository.save(user);
    }

    // ==================== GESTION SESSION ====================

    private Session createSession(User user, String ipAddress, String deviceInfo) {
        String token = UUID.randomUUID().toString();
        LocalDateTime expiresAt = LocalDateTime.now().plusMinutes(sessionExpiryMinutes);

        Session session = Session.builder()
                .user(user)
                .token(token)
                .ipAddress(ipAddress)
                .deviceInfo(deviceInfo)
                .expiresAt(expiresAt)
                .isActive(true)
                .build();

        return sessionRepository.save(session);
    }

    public Optional<Session> validateSession(String token) {
        Optional<Session> sessionOpt = sessionRepository.findByToken(token);

        if (sessionOpt.isEmpty()) {
            return Optional.empty();
        }

        Session session = sessionOpt.get();

        if (!session.isValid()) {
            return Optional.empty();
        }

        // Mettre à jour l'activité
        session.updateActivity();
        sessionRepository.save(session);

        return Optional.of(session);
    }

    @Transactional
    public Session logout(String token) {
        Optional<Session> sessionOpt = sessionRepository.findByToken(token);
        if (sessionOpt.isPresent()) {
            Session session = sessionOpt.get();

            // Vérifier si la session est déjà invalide
            if (!session.isValid()) {
                throw new RuntimeException("Session déjà déconnectée ou expirée");
            }

            session.invalidate();
            sessionRepository.save(session);
            return session;
        }
        throw new RuntimeException("Session introuvable");
    }

    @Transactional
    public void logoutAllUserSessions(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Utilisateur introuvable"));
        sessionRepository.invalidateAllUserSessions(user);
    }

    // ==================== UTILITAIRE TEST - LOGOUT ALL ====================

    @Transactional
    public int logoutAllSessions() {
        List<Session> allSessions = sessionRepository.findAll();
        int count = 0;
        for (Session session : allSessions) {
            if (session.getIsActive()) {
                session.invalidate();
                sessionRepository.save(session);
                count++;
            }
        }
        log.info("Toutes les sessions déconnectées: {} sessions", count);
        return count;
    }

    // ==================== GESTION TENTATIVES ÉCHOUÉES ====================

    private void recordLoginAttempt(String email, User user, boolean success,
                                    FailureReason reason, String ipAddress, String userAgent) {
        LoginAttempt attempt = LoginAttempt.builder()
                .email(email)
                .user(user)
                .success(success)
                .failureReason(reason)
                .ipAddress(ipAddress)
                .userAgent(userAgent)
                .build();

        loginAttemptRepository.save(attempt);
    }

    // ==================== RESET TENTATIVES ====================

    @Transactional
    public void resetFailedAttempts(String email, User user) {
        // Reset tracking
        failedLoginTrackingRepository.findByEmail(email).ifPresent(tracking -> {
            tracking.reset();
            failedLoginTrackingRepository.save(tracking);
        });

        // Reset user
        if (user != null) {
            user.resetFailedAttempts();
            user.unlockAccount();
            userRepository.save(user);
        }
    }

    // ==================== API DÉBLOCAGE (MANAGER) ====================

    @Transactional
    public void unlockAccount(String email, User unlockedBy) {
        if (!unlockedBy.isManager()) {
            throw new RuntimeException("Seul un Manager peut débloquer un compte");
        }

        // Débloquer dans failed_login_tracking
        FailedLoginTracking tracking = failedLoginTrackingRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Aucun blocage trouvé pour cet email"));

        tracking.unblock(unlockedBy);
        failedLoginTrackingRepository.save(tracking);

        // Débloquer dans users
        userRepository.findByEmail(email).ifPresent(user -> {
            user.unlockAccount();
            userRepository.save(user);
        });

        log.info("Compte {} débloqué par le Manager {}", email, unlockedBy.getEmail());
    }

    // ==================== UTILITAIRES ====================

    private boolean isOnline() {
        return "online".equalsIgnoreCase(appMode) && NetworkUtils.isInternetAvailable();
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    // ==================== NETTOYAGE SESSIONS EXPIRÉES ====================

    @Transactional
    public void cleanupExpiredSessions() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime expirationDate = now.minusDays(7); // Garder 7 jours d'historique
        sessionRepository.deleteExpiredSessions(expirationDate);
        log.info("Sessions expirées nettoyées");
    }
}



============================================================
FILE: EntrepriseService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.EntrepriseRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class EntrepriseService {

    private final EntrepriseRepository entrepriseRepository;

    public Entreprise create(Entreprise entreprise, User createdBy) {
        log.info("Création d'une nouvelle entreprise: {}", entreprise.getNom());
        
        if (existsByNom(entreprise.getNom())) {
            throw new IllegalArgumentException("Une entreprise avec ce nom existe déjà");
        }
        
        if (entreprise.getSiret() != null && existsBySiret(entreprise.getSiret())) {
            throw new IllegalArgumentException("Une entreprise avec ce SIRET existe déjà");
        }
        
        entreprise.setCreatedBy(createdBy);
        entreprise.setIsActive(true);
        entreprise.setNombreInterventions(0);
        
        return entrepriseRepository.save(entreprise);
    }

    public Entreprise update(Integer id, Entreprise entreprise) {
        log.info("Mise à jour de l'entreprise avec l'ID: {}", id);
        
        Entreprise existingEntreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        if (!existingEntreprise.getNom().equals(entreprise.getNom())) {
            if (existsByNom(entreprise.getNom())) {
                throw new IllegalArgumentException("Une entreprise avec ce nom existe déjà");
            }
            existingEntreprise.setNom(entreprise.getNom());
        }
        
        if (entreprise.getSiret() != null && !entreprise.getSiret().equals(existingEntreprise.getSiret())) {
            if (existsBySiret(entreprise.getSiret())) {
                throw new IllegalArgumentException("Une entreprise avec ce SIRET existe déjà");
            }
            existingEntreprise.setSiret(entreprise.getSiret());
        }
        
        existingEntreprise.setTelephone(entreprise.getTelephone());
        existingEntreprise.setEmail(entreprise.getEmail());
        existingEntreprise.setAdresse(entreprise.getAdresse());
        existingEntreprise.setSpecialites(entreprise.getSpecialites());
        
        return entrepriseRepository.save(existingEntreprise);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findById(Integer id) {
        log.debug("Recherche de l'entreprise avec l'ID: {}", id);
        return entrepriseRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findAll() {
        log.debug("Récupération de toutes les entreprises");
        return entrepriseRepository.findAll();
    }

    public void delete(Integer id) {
        log.info("Suppression de l'entreprise avec l'ID: {}", id);
        
        if (!entrepriseRepository.existsById(id)) {
            throw new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id);
        }
        
        entrepriseRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findByNom(String nom) {
        log.debug("Recherche de l'entreprise par nom: {}", nom);
        return entrepriseRepository.findByNom(nom);
    }

    @Transactional(readOnly = true)
    public Optional<Entreprise> findBySiret(String siret) {
        log.debug("Recherche de l'entreprise par SIRET: {}", siret);
        return entrepriseRepository.findBySiret(siret);
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findActiveEntreprises() {
        log.debug("Récupération des entreprises actives");
        return entrepriseRepository.findByIsActiveTrue();
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findTopRatedEntreprises() {
        log.debug("Récupération des entreprises les mieux notées");
        return entrepriseRepository.findTopRatedEntreprises();
    }

    @Transactional(readOnly = true)
    public List<Entreprise> findBySpecialite(String specialite) {
        log.debug("Recherche des entreprises par spécialité: {}", specialite);
        
        return entrepriseRepository.findByIsActiveTrue().stream()
                .filter(entreprise -> entreprise.getSpecialites() != null 
                        && Arrays.asList(entreprise.getSpecialites()).contains(specialite))
                .collect(Collectors.toList());
    }

    public Entreprise activateEntreprise(Integer id) {
        log.info("Activation de l'entreprise avec l'ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.setIsActive(true);
        return entrepriseRepository.save(entreprise);
    }

    public Entreprise deactivateEntreprise(Integer id) {
        log.info("Désactivation de l'entreprise avec l'ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.setIsActive(false);
        return entrepriseRepository.save(entreprise);
    }

    public void incrementInterventions(Integer id) {
        log.info("Incrémentation du nombre d'interventions pour l'entreprise ID: {}", id);
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.incrementInterventions();
        entrepriseRepository.save(entreprise);
    }

    public void updateNoteMoyenne(Integer id, BigDecimal nouvelleNote) {
        log.info("Mise à jour de la note moyenne pour l'entreprise ID: {}", id);
        
        if (nouvelleNote == null || nouvelleNote.compareTo(BigDecimal.ZERO) < 0 
                || nouvelleNote.compareTo(BigDecimal.valueOf(5)) > 0) {
            throw new IllegalArgumentException("La note doit être comprise entre 0 et 5");
        }
        
        Entreprise entreprise = entrepriseRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée avec l'ID: " + id));
        
        entreprise.updateNoteMoyenne(nouvelleNote);
        entrepriseRepository.save(entreprise);
    }

    @Transactional(readOnly = true)
    public boolean existsByNom(String nom) {
        return entrepriseRepository.findByNom(nom).isPresent();
    }

    @Transactional(readOnly = true)
    public boolean existsBySiret(String siret) {
        return entrepriseRepository.findBySiret(siret).isPresent();
    }
}



============================================================
FILE: HistoriqueStatusService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.HistoriqueStatus;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.HistoriqueStatusRepository;
import mg.projetfinal.repository.SignalementRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class HistoriqueStatusService {

    private final HistoriqueStatusRepository historiqueStatusRepository;
    private final SignalementRepository signalementRepository;

    public HistoriqueStatus create(HistoriqueStatus historique) {
        log.info("Création d'un nouvel historique de statut");
        
        if (historique.getSignalement() == null) {
            throw new IllegalArgumentException("Le signalement est obligatoire");
        }
        
        if (historique.getAncienStatus() == null || historique.getNouveauStatus() == null) {
            throw new IllegalArgumentException("L'ancien et le nouveau statut sont obligatoires");
        }
        
        if (historique.getModifiedBy() == null) {
            throw new IllegalArgumentException("L'utilisateur qui a modifié le statut est obligatoire");
        }
        
        return historiqueStatusRepository.save(historique);
    }

    @Transactional(readOnly = true)
    public Optional<HistoriqueStatus> findById(Long id) {
        log.debug("Recherche de l'historique avec l'ID: {}", id);
        return historiqueStatusRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findAll() {
        log.debug("Récupération de tous les historiques");
        return historiqueStatusRepository.findAll();
    }

    public void delete(Long id) {
        log.info("Suppression de l'historique avec l'ID: {}", id);
        
        if (!historiqueStatusRepository.existsById(id)) {
            throw new IllegalArgumentException("Historique non trouvé avec l'ID: " + id);
        }
        
        historiqueStatusRepository.deleteById(id);
    }

    public HistoriqueStatus createHistorique(
            Signalement signalement,
            SignalementStatus ancienStatus,
            SignalementStatus nouveauStatus,
            User modifiedBy,
            String commentaire) {
        
        return createHistorique(signalement, ancienStatus, nouveauStatus, modifiedBy, commentaire, null);
    }

    public HistoriqueStatus createHistorique(
            Signalement signalement,
            SignalementStatus ancienStatus,
            SignalementStatus nouveauStatus,
            User modifiedBy,
            String commentaire,
            Map<String, Object> metadata) {
        
        log.info("Création d'un historique de changement de statut pour le signalement ID: {}", signalement.getId());
        
        HistoriqueStatus historique = HistoriqueStatus.builder()
                .signalement(signalement)
                .ancienStatus(ancienStatus)
                .nouveauStatus(nouveauStatus)
                .modifiedBy(modifiedBy)
                .commentaire(commentaire)
                .metadata(metadata)
                .build();
        
        HistoriqueStatus savedHistorique = historiqueStatusRepository.save(historique);
        
        signalement.addHistorique(savedHistorique);
        
        return savedHistorique;
    }

    public HistoriqueStatus createInitialHistorique(Signalement signalement, User createdBy) {
        log.info("Création de l'historique initial pour le signalement ID: {}", signalement.getId());
        
        SignalementStatus initialStatus = signalement.getStatus();
        
        Map<String, Object> metadata = new HashMap<>();
        metadata.put("initial", true);
        metadata.put("createdAt", signalement.getCreatedAt());
        
        HistoriqueStatus historique = HistoriqueStatus.builder()
                .signalement(signalement)
                .ancienStatus(initialStatus)
                .nouveauStatus(initialStatus)
                .modifiedBy(createdBy)
                .commentaire("Création du signalement")
                .metadata(metadata)
                .build();
        
        HistoriqueStatus savedHistorique = historiqueStatusRepository.save(historique);
        
        signalement.addHistorique(savedHistorique);
        
        return savedHistorique;
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findBySignalement(Signalement signalement) {
        log.debug("Recherche des historiques pour le signalement ID: {}", signalement.getId());
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findBySignalementOrderByDate(Signalement signalement) {
        log.debug("Recherche des historiques triés par date pour le signalement ID: {}", signalement.getId());
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> findByUser(User user) {
        log.debug("Recherche des historiques pour l'utilisateur ID: {}", user.getId());
        
        return historiqueStatusRepository.findAll().stream()
                .filter(h -> h.getModifiedBy().equals(user))
                .toList();
    }

    @Transactional(readOnly = true)
    public HistoriqueStatus getLastStatusChange(Signalement signalement) {
        log.debug("Récupération du dernier changement de statut pour le signalement ID: {}", signalement.getId());
        
        List<HistoriqueStatus> historiques = historiqueStatusRepository
                .findBySignalementOrderByChangedAtDesc(signalement);
        
        return historiques.isEmpty() ? null : historiques.get(0);
    }

    @Transactional(readOnly = true)
    public List<HistoriqueStatus> getStatusHistory(Long signalementId) {
        log.debug("Récupération de l'historique complet pour le signalement ID: {}", signalementId);
        
        Signalement signalement = signalementRepository.findById(signalementId)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + signalementId));
        
        return historiqueStatusRepository.findBySignalementOrderByChangedAtDesc(signalement);
    }

    @Transactional(readOnly = true)
    public long countStatusChangesByUser(User user) {
        log.debug("Comptage des changements de statut effectués par l'utilisateur ID: {}", user.getId());
        
        return historiqueStatusRepository.findAll().stream()
                .filter(h -> h.getModifiedBy().equals(user))
                .count();
    }
}



============================================================
FILE: SignalementActionService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.SignalementAction;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.SignalementActionRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class SignalementActionService {

    private final SignalementActionRepository signalementActionRepository;
    private final EntrepriseService entrepriseService;

    public SignalementAction create(SignalementAction action, User createdBy) {
        log.info("Création d'une nouvelle action pour le signalement ID: {}", action.getSignalement().getId());
        
        if (action.getSignalement() == null) {
            throw new IllegalArgumentException("Le signalement est obligatoire");
        }
        
        if (action.getDescriptionTravaux() == null || action.getDescriptionTravaux().trim().isEmpty()) {
            throw new IllegalArgumentException("La description des travaux est obligatoire");
        }
        
        action.setCreatedBy(createdBy);
        
        SignalementAction savedAction = signalementActionRepository.save(action);
        
        // Incrémenter le nombre d'interventions de l'entreprise si elle est assignée
        if (action.getEntreprise() != null) {
            entrepriseService.incrementInterventions(action.getEntreprise().getId());
        }
        
        return savedAction;
    }

    public SignalementAction update(Long id, SignalementAction action, User modifiedBy) {
        log.info("Mise à jour de l'action avec l'ID: {}", id);
        
        SignalementAction existingAction = signalementActionRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + id));
        
        existingAction.setDescriptionTravaux(action.getDescriptionTravaux());
        existingAction.setMaterielUtilise(action.getMaterielUtilise());
        existingAction.setSurfaceM2(action.getSurfaceM2());
        existingAction.setBudget(action.getBudget());
        existingAction.setDateDebutTravaux(action.getDateDebutTravaux());
        existingAction.setDateFinPrevue(action.getDateFinPrevue());
        existingAction.setPhotosAvant(action.getPhotosAvant());
        existingAction.setPhotosApres(action.getPhotosApres());
        existingAction.setModifiedBy(modifiedBy);
        
        // Si l'entreprise change, mettre à jour les compteurs
        if (action.getEntreprise() != null && 
                !action.getEntreprise().equals(existingAction.getEntreprise())) {
            existingAction.setEntreprise(action.getEntreprise());
            entrepriseService.incrementInterventions(action.getEntreprise().getId());
        }
        
        return signalementActionRepository.save(existingAction);
    }

    @Transactional(readOnly = true)
    public Optional<SignalementAction> findById(Long id) {
        log.debug("Recherche de l'action avec l'ID: {}", id);
        return signalementActionRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findAll() {
        log.debug("Récupération de toutes les actions");
        return signalementActionRepository.findAll();
    }

    public void delete(Long id) {
        log.info("Suppression de l'action avec l'ID: {}", id);
        
        if (!signalementActionRepository.existsById(id)) {
            throw new IllegalArgumentException("Action non trouvée avec l'ID: " + id);
        }
        
        signalementActionRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findBySignalement(Signalement signalement) {
        log.debug("Recherche des actions pour le signalement ID: {}", signalement.getId());
        return signalementActionRepository.findBySignalement(signalement);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findByEntreprise(Entreprise entreprise) {
        log.debug("Recherche des actions pour l'entreprise ID: {}", entreprise.getId());
        return signalementActionRepository.findByEntreprise(entreprise);
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsEnCours() {
        log.debug("Récupération des actions en cours");
        return signalementActionRepository.findActionsEnCours();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsEnRetard() {
        log.debug("Récupération des actions en retard");
        return signalementActionRepository.findActionsEnRetard();
    }

    public SignalementAction assignerEntreprise(Long actionId, Entreprise entreprise, User modifiedBy) {
        log.info("Assignation de l'entreprise ID: {} à l'action ID: {}", entreprise.getId(), actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getEntreprise() != null) {
            log.warn("L'action possède déjà une entreprise assignée");
        }
        
        action.setEntreprise(entreprise);
        action.setModifiedBy(modifiedBy);
        
        entrepriseService.incrementInterventions(entreprise.getId());
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction demarrerTravaux(Long actionId, LocalDateTime dateDebut, User modifiedBy) {
        log.info("Démarrage des travaux pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateDebutTravaux() != null) {
            throw new IllegalStateException("Les travaux ont déjà démarré");
        }
        
        if (action.getEntreprise() == null) {
            throw new IllegalStateException("Une entreprise doit être assignée avant de démarrer les travaux");
        }
        
        action.setDateDebutTravaux(dateDebut != null ? dateDebut : LocalDateTime.now());
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction terminerTravaux(Long actionId, boolean conformes, String commentaire, User modifiedBy) {
        log.info("Fin des travaux pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateDebutTravaux() == null) {
            throw new IllegalStateException("Les travaux n'ont pas encore démarré");
        }
        
        if (action.getDateFinReelle() != null) {
            throw new IllegalStateException("Les travaux sont déjà terminés");
        }
        
        action.terminerTravaux(conformes, commentaire);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction ajouterPhotosAvant(Long actionId, String[] photos, User modifiedBy) {
        log.info("Ajout de {} photos avant pour l'action ID: {}", photos.length, actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        action.setPhotosAvant(photos);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction ajouterPhotosApres(Long actionId, String[] photos, User modifiedBy) {
        log.info("Ajout de {} photos après pour l'action ID: {}", photos.length, actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (action.getDateFinReelle() == null) {
            log.warn("Les travaux ne sont pas encore terminés");
        }
        
        action.setPhotosApres(photos);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction updateBudget(Long actionId, BigDecimal budget, User modifiedBy) {
        log.info("Mise à jour du budget pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (budget == null || budget.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Le budget doit être positif");
        }
        
        action.setBudget(budget);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    public SignalementAction updateDateFinPrevue(Long actionId, LocalDateTime dateFinPrevue, User modifiedBy) {
        log.info("Mise à jour de la date de fin prévue pour l'action ID: {}", actionId);
        
        SignalementAction action = signalementActionRepository.findById(actionId)
                .orElseThrow(() -> new IllegalArgumentException("Action non trouvée avec l'ID: " + actionId));
        
        if (dateFinPrevue != null && action.getDateDebutTravaux() != null 
                && dateFinPrevue.isBefore(action.getDateDebutTravaux())) {
            throw new IllegalArgumentException("La date de fin prévue ne peut pas être avant la date de début");
        }
        
        action.setDateFinPrevue(dateFinPrevue);
        action.setModifiedBy(modifiedBy);
        
        return signalementActionRepository.save(action);
    }

    @Transactional(readOnly = true)
    public long countActionsEnCours() {
        return signalementActionRepository.findActionsEnCours().size();
    }

    @Transactional(readOnly = true)
    public long countActionsEnRetard() {
        return signalementActionRepository.findActionsEnRetard().size();
    }

    @Transactional(readOnly = true)
    public long countActionsByEntreprise(Entreprise entreprise) {
        return signalementActionRepository.findByEntreprise(entreprise).size();
    }

    @Transactional(readOnly = true)
    public long countActionsTerminees() {
        return signalementActionRepository.findAll().stream()
                .filter(SignalementAction::isTermine)
                .count();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsConformes() {
        log.debug("Récupération des actions conformes");
        return signalementActionRepository.findAll().stream()
                .filter(action -> action.getTravauxConformes() != null && action.getTravauxConformes())
                .toList();
    }

    @Transactional(readOnly = true)
    public List<SignalementAction> findActionsNonConformes() {
        log.debug("Récupération des actions non conformes");
        return signalementActionRepository.findAll().stream()
                .filter(action -> action.getTravauxConformes() != null && !action.getTravauxConformes())
                .toList();
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateBudgetTotal() {
        log.debug("Calcul du budget total de toutes les actions");
        return signalementActionRepository.findAll().stream()
                .map(SignalementAction::getBudget)
                .filter(budget -> budget != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Transactional(readOnly = true)
    public BigDecimal calculateBudgetByEntreprise(Entreprise entreprise) {
        log.debug("Calcul du budget total pour l'entreprise ID: {}", entreprise.getId());
        return signalementActionRepository.findByEntreprise(entreprise).stream()
                .map(SignalementAction::getBudget)
                .filter(budget -> budget != null)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}



============================================================
FILE: SignalementService.java
PACKAGE: mg.projetfinal.service
============================================================

package mg.projetfinal.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.repository.SignalementRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class SignalementService {

    private final SignalementRepository signalementRepository;
    private final HistoriqueStatusService historiqueStatusService;

    public Signalement create(Signalement signalement, User user) {
        log.info("Création d'un nouveau signalement pour l'utilisateur: {}", user.getId());
        
        if (signalement.getLatitude() == null || signalement.getLongitude() == null) {
            throw new IllegalArgumentException("La localisation (latitude et longitude) est obligatoire");
        }
        
        if (signalement.getDescription() == null || signalement.getDescription().trim().isEmpty()) {
            throw new IllegalArgumentException("La description est obligatoire");
        }
        
        signalement.setUser(user);
        signalement.setFirebaseSynced(false);
        
        Signalement savedSignalement = signalementRepository.save(signalement);
        
        if (signalement.getStatus() != null) {
            historiqueStatusService.createInitialHistorique(savedSignalement, user);
        }
        
        return savedSignalement;
    }

    public Signalement update(Long id, Signalement signalement) {
        log.info("Mise à jour du signalement avec l'ID: {}", id);
        
        Signalement existingSignalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        existingSignalement.setDescription(signalement.getDescription());
        existingSignalement.setAdresse(signalement.getAdresse());
        existingSignalement.setPhotoUrl(signalement.getPhotoUrl());
        
        if (!existingSignalement.getLatitude().equals(signalement.getLatitude()) 
                || !existingSignalement.getLongitude().equals(signalement.getLongitude())) {
            existingSignalement.setLatitude(signalement.getLatitude());
            existingSignalement.setLongitude(signalement.getLongitude());
            existingSignalement.setFirebaseSynced(false);
        }
        
        return signalementRepository.save(existingSignalement);
    }

    @Transactional(readOnly = true)
    public Optional<Signalement> findById(Long id) {
        log.debug("Recherche du signalement avec l'ID: {}", id);
        return signalementRepository.findById(id);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findAll() {
        log.debug("Récupération de tous les signalements");
        return signalementRepository.findAll();
    }

    @Transactional(readOnly = true)
    public List<Signalement> findAllOrderByDateDesc() {
        log.debug("Récupération de tous les signalements triés par date");
        return signalementRepository.findAllOrderByDateDesc();
    }

    public void delete(Long id) {
        log.info("Suppression du signalement avec l'ID: {}", id);
        
        if (!signalementRepository.existsById(id)) {
            throw new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id);
        }
        
        signalementRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByUser(User user) {
        log.debug("Recherche des signalements pour l'utilisateur: {}", user.getId());
        return signalementRepository.findByUser(user);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByStatus(SignalementStatus status) {
        log.debug("Recherche des signalements par statut: {}", status.getCode());
        return signalementRepository.findByStatus(status);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByStatusCode(String statusCode) {
        log.debug("Recherche des signalements par code de statut: {}", statusCode);
        return signalementRepository.findByStatusCode(statusCode);
    }

    @Transactional(readOnly = true)
    public List<Signalement> findNonSyncedWithFirebase() {
        log.debug("Récupération des signalements non synchronisés avec Firebase");
        return signalementRepository.findByFirebaseSyncedFalse();
    }

    @Transactional(readOnly = true)
    public List<Signalement> findByLocation(BigDecimal latitude, BigDecimal longitude, double radiusKm) {
        log.debug("Recherche des signalements dans un rayon de {} km autour de ({}, {})", 
                radiusKm, latitude, longitude);
        
        return signalementRepository.findAll().stream()
                .filter(signalement -> {
                    double distance = calculateDistance(
                            latitude.doubleValue(), 
                            longitude.doubleValue(),
                            signalement.getLatitude().doubleValue(),
                            signalement.getLongitude().doubleValue()
                    );
                    return distance <= radiusKm;
                })
                .collect(Collectors.toList());
    }

    public Signalement changeStatus(Long id, SignalementStatus newStatus, User modifiedBy, String commentaire) {
        log.info("Changement de statut pour le signalement ID: {} vers {}", id, newStatus.getCode());
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        SignalementStatus oldStatus = signalement.getStatus();
        
        if (oldStatus.equals(newStatus)) {
            log.warn("Le signalement est déjà au statut: {}", newStatus.getCode());
            return signalement;
        }
        
        historiqueStatusService.createHistorique(signalement, oldStatus, newStatus, modifiedBy, commentaire);
        
        signalement.setStatus(newStatus);
        signalement.setFirebaseSynced(false);
        
        return signalementRepository.save(signalement);
    }

    public void markAsSynced(Long id, String firebaseId) {
        log.info("Marquage du signalement ID: {} comme synchronisé avec Firebase ID: {}", id, firebaseId);
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        signalement.setFirebaseId(firebaseId);
        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
        
        signalementRepository.save(signalement);
    }

    public void syncWithFirebase(Long id) {
        log.info("Synchronisation du signalement ID: {} avec Firebase", id);
        
        Signalement signalement = signalementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé avec l'ID: " + id));
        
        // TODO: Implémenter la logique de synchronisation avec Firebase
        signalement.setFirebaseSynced(true);
        signalement.setLastSyncAt(LocalDateTime.now());
        
        signalementRepository.save(signalement);
    }

    public List<Signalement> syncAllPending() {
        log.info("Synchronisation de tous les signalements en attente avec Firebase");
        
        List<Signalement> pendingSignalements = findNonSyncedWithFirebase();
        
        for (Signalement signalement : pendingSignalements) {
            try {
                syncWithFirebase(signalement.getId());
            } catch (Exception e) {
                log.error("Erreur lors de la synchronisation du signalement ID: {}", signalement.getId(), e);
            }
        }
        
        return pendingSignalements;
    }

    @Transactional(readOnly = true)
    public long countByStatus(SignalementStatus status) {
        return signalementRepository.findByStatus(status).size();
    }

    @Transactional(readOnly = true)
    public long countByUser(User user) {
        return signalementRepository.findByUser(user).size();
    }

    @Transactional(readOnly = true)
    public long countNouveau() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isNouveau)
                .count();
    }

    @Transactional(readOnly = true)
    public long countEnCours() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isEnCours)
                .count();
    }

    @Transactional(readOnly = true)
    public long countTermine() {
        return signalementRepository.findAll().stream()
                .filter(Signalement::isTermine)
                .count();
    }

    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        final int EARTH_RADIUS = 6371;
        
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                   Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                   Math.sin(dLon / 2) * Math.sin(dLon / 2);
        
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return EARTH_RADIUS * c;
    }
}



