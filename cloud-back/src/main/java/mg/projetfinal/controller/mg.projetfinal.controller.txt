============================================================
FILE: AdminController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.dto.AuthResponse;
import mg.projetfinal.dto.LoginManagerRequest;
import mg.projetfinal.dto.LoginResponse;
import mg.projetfinal.dto.RegisterAdminRequest;
import mg.projetfinal.entity.Session;
import mg.projetfinal.entity.User;
import mg.projetfinal.service.AuthService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Administration", description = "API de gestion des administrateurs")
public class AdminController {

    private final AuthService authService;

    @Value("${admin.secret-key}")
    private String adminSecretKey;

    @PostMapping("/register")
    @Operation(summary = "Créer un compte administrateur (MANAGER)")
    public ResponseEntity<AuthResponse> registerAdmin(@RequestBody RegisterAdminRequest request) {
        try {
            // Vérifier la clé secrète
            if (request.getSecretKey() == null || !request.getSecretKey().equals(adminSecretKey)) {
                log.warn("Tentative de création admin avec clé secrète invalide");
                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                        AuthResponse.builder()
                                .success(false)
                                .message("Clé secrète invalide")
                                .build()
                );
            }

            // Créer l'admin
            User admin = authService.registerAdmin(
                    request.getEmail(),
                    request.getPassword(),
                    request.getName()
            );

            log.info("Admin créé avec succès: {}", admin.getEmail());

            return ResponseEntity.status(HttpStatus.CREATED).body(
                    AuthResponse.builder()
                            .success(true)
                            .message("Compte administrateur créé avec succès")
                            .userId(admin.getId())
                            .email(admin.getEmail())
                            .name(admin.getName())
                            .role(admin.getRole().getCode())
                            .build()
            );

        } catch (Exception e) {
            log.error("Erreur lors de la création admin: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/login")
    @Operation(summary = "Connexion manager (sans blocage)")
    public ResponseEntity<LoginResponse> loginManager(@RequestBody LoginManagerRequest request, HttpServletRequest httpRequest) {
        try {
            Session session = authService.loginManager(request.getEmail(), request.getPassword(), httpRequest);

            return ResponseEntity.ok(
                    LoginResponse.builder()
                            .success(true)
                            .message("Connexion manager réussie")
                            .token(session.getToken())
                            .userId(session.getUser().getId())
                            .email(session.getUser().getEmail())
                            .name(session.getUser().getName())
                            .role(session.getUser().getRole().getCode())
                            .expiresAt(session.getExpiresAt())
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    LoginResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }
}



============================================================
FILE: AuthController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import mg.projetfinal.dto.*;
import mg.projetfinal.entity.Session;
import mg.projetfinal.entity.User;
import mg.projetfinal.service.AuthService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Tag(name = "Authentification", description = "API de gestion de l'authentification")
public class AuthController {

    private final AuthService authService;

    @PostMapping("/register")
    @Operation(summary = "Inscription d'un nouvel utilisateur")
    public ResponseEntity<AuthResponse> register(@RequestBody RegisterRequest request, HttpServletRequest httpRequest) {
        try {
            User createdBy = getCurrentUser(httpRequest);

            User user = authService.register(
                    request.getEmail(),
                    request.getPassword(),
                    request.getName(),
                    createdBy
            );

            return ResponseEntity.status(HttpStatus.CREATED).body(
                    AuthResponse.builder()
                            .success(true)
                            .message("Compte créé avec succès")
                            .userId(user.getId())
                            .email(user.getEmail())
                            .name(user.getName())
                            .role(user.getRole().getCode())
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/login")
    @Operation(summary = "Connexion d'un utilisateur")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest request, HttpServletRequest httpRequest) {
        try {
            Session session = authService.login(request.getEmail(), request.getPassword(), httpRequest);

            return ResponseEntity.ok(
                    LoginResponse.builder()
                            .success(true)
                            .message("Connexion réussie")
                            .token(session.getToken())
                            .userId(session.getUser().getId())
                            .email(session.getUser().getEmail())
                            .name(session.getUser().getName())
                            .role(session.getUser().getRole().getCode())
                            .expiresAt(session.getExpiresAt())
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    LoginResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/logout")
    @Operation(summary = "Déconnexion d'un utilisateur")
    public ResponseEntity<AuthResponse> logout(@RequestHeader("Authorization") String authHeader) {
        try {
            String token = extractToken(authHeader);
            Session session = authService.logout(token);

            return ResponseEntity.ok(
                    AuthResponse.builder()
                            .success(true)
                            .message("Déconnexion réussie")
                            .userId(session.getUser().getId())
                            .email(session.getUser().getEmail())
                            .name(session.getUser().getName())
                            .role(session.getUser().getRole().getCode())
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PutMapping("/update/{userId}")
    @Operation(summary = "Modification des informations utilisateur")
    public ResponseEntity<AuthResponse> updateUser(
            @PathVariable Long userId,
            @RequestBody UpdateUserRequest request,
            HttpServletRequest httpRequest) {
        try {
            User modifiedBy = getCurrentUser(httpRequest);

            User updatedUser = authService.updateUser(
                    userId,
                    request.getName(),
                    request.getPassword(),
                    modifiedBy
            );

            return ResponseEntity.ok(
                    AuthResponse.builder()
                            .success(true)
                            .message("Informations mises à jour avec succès")
                            .userId(updatedUser.getId())
                            .email(updatedUser.getEmail())
                            .name(updatedUser.getName())
                            .role(updatedUser.getRole().getCode())
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/unlock/{email}")
    @Operation(summary = "Débloquer un compte utilisateur (Manager uniquement)")
    public ResponseEntity<AuthResponse> unlockAccount(
            @PathVariable String email,
            HttpServletRequest httpRequest) {
        try {
            User manager = getCurrentUser(httpRequest);

            if (manager == null || !manager.isManager()) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                        AuthResponse.builder()
                                .success(false)
                                .message("Accès refusé. Seul un Manager peut débloquer un compte.")
                                .build()
                );
            }

            authService.unlockAccount(email, manager);

            return ResponseEntity.ok(
                    AuthResponse.builder()
                            .success(true)
                            .message("Compte " + email + " débloqué avec succès")
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @GetMapping("/validate")
    @Operation(summary = "Valider une session")
    public ResponseEntity<SessionResponse> validateSession(@RequestHeader("Authorization") String authHeader) {
        try {
            String token = extractToken(authHeader);

            return authService.validateSession(token)
                    .map(session -> ResponseEntity.ok(
                            SessionResponse.builder()
                                    .success(true)
                                    .valid(true)
                                    .userId(session.getUser().getId())
                                    .email(session.getUser().getEmail())
                                    .name(session.getUser().getName())
                                    .role(session.getUser().getRole().getCode())
                                    .expiresAt(session.getExpiresAt())
                                    .build()
                    ))
                    .orElse(ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                            SessionResponse.builder()
                                    .success(false)
                                    .valid(false)
                                    .message("Session invalide ou expirée")
                                    .build()
                    ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    SessionResponse.builder()
                            .success(false)
                            .valid(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/logout-all/{userId}")
    @Operation(summary = "Déconnecter toutes les sessions d'un utilisateur")
    public ResponseEntity<AuthResponse> logoutAllSessions(
            @PathVariable Long userId,
            HttpServletRequest httpRequest) {
        try {
            User currentUser = getCurrentUser(httpRequest);

            if (!currentUser.getId().equals(userId) && !currentUser.isManager()) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
                        AuthResponse.builder()
                                .success(false)
                                .message("Permission refusée")
                                .build()
                );
            }

            authService.logoutAllUserSessions(userId);

            return ResponseEntity.ok(
                    AuthResponse.builder()
                            .success(true)
                            .message("Toutes les sessions ont été fermées")
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping("/test/logout-all-sessions")
    @Operation(summary = "UTILITAIRE TEST - Déconnecter TOUTES les sessions")
    public ResponseEntity<AuthResponse> logoutAllSessionsTest() {
        try {
            int count = authService.logoutAllSessions();

            return ResponseEntity.ok(
                    AuthResponse.builder()
                            .success(true)
                            .message(count + " sessions déconnectées")
                            .build()
            );
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(
                    AuthResponse.builder()
                            .success(false)
                            .message(e.getMessage())
                            .build()
            );
        }
    }

    private String extractToken(String authHeader) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            throw new RuntimeException("Token manquant ou invalide");
        }
        return authHeader.substring(7);
    }

    private User getCurrentUser(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return null;
        }

        String token = authHeader.substring(7);
        return authService.validateSession(token)
                .map(Session::getUser)
                .orElse(null);
    }
}



============================================================
FILE: EntrepriseController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.dto.EntrepriseResponseDTO;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.User;
import mg.projetfinal.mapper.SignalementMapper;
import mg.projetfinal.service.EntrepriseService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.util.List;

@RestController
@RequestMapping("/api/entreprises")
@RequiredArgsConstructor
@Slf4j
@CrossOrigin(origins = "*")
public class EntrepriseController {

    private final EntrepriseService entrepriseService;
    private final SignalementMapper mapper;

    /**
     * GET /api/entreprises
     * Récupère toutes les entreprises
     */
    @GetMapping
    public ResponseEntity<List<EntrepriseResponseDTO>> getAllEntreprises() {
        log.info("GET /api/entreprises - Récupération de toutes les entreprises");

        List<Entreprise> entreprises = entrepriseService.findAll();
        List<EntrepriseResponseDTO> response = mapper.toEntrepriseDTOList(entreprises);

        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/entreprises/active
     * Récupère les entreprises actives
     */
    @GetMapping("/active")
    public ResponseEntity<List<EntrepriseResponseDTO>> getActiveEntreprises() {
        log.info("GET /api/entreprises/active - Récupération des entreprises actives");

        List<Entreprise> entreprises = entrepriseService.findActiveEntreprises();
        List<EntrepriseResponseDTO> response = mapper.toEntrepriseDTOList(entreprises);

        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/entreprises/top-rated
     * Récupère les entreprises les mieux notées
     */
    @GetMapping("/top-rated")
    public ResponseEntity<List<EntrepriseResponseDTO>> getTopRatedEntreprises() {
        log.info("GET /api/entreprises/top-rated - Récupération des meilleures entreprises");

        List<Entreprise> entreprises = entrepriseService.findTopRatedEntreprises();
        List<EntrepriseResponseDTO> response = mapper.toEntrepriseDTOList(entreprises);

        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/entreprises/{id}
     * Récupère une entreprise par ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<EntrepriseResponseDTO> getEntrepriseById(@PathVariable Integer id) {
        log.info("GET /api/entreprises/{} - Récupération de l'entreprise", id);

        return entrepriseService.findById(id)
                .map(mapper::toEntrepriseDTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * GET /api/entreprises/by-specialite
     * Récupère les entreprises par spécialité
     */
    @GetMapping("/by-specialite")
    public ResponseEntity<List<EntrepriseResponseDTO>> getEntreprisesBySpecialite(
            @RequestParam String specialite) {

        log.info("GET /api/entreprises/by-specialite?specialite={}", specialite);

        List<Entreprise> entreprises = entrepriseService.findBySpecialite(specialite);
        List<EntrepriseResponseDTO> response = mapper.toEntrepriseDTOList(entreprises);

        return ResponseEntity.ok(response);
    }

    /**
     * POST /api/entreprises
     * Crée une nouvelle entreprise
     */
    @PostMapping
    public ResponseEntity<EntrepriseResponseDTO> createEntreprise(
            @RequestBody Entreprise entreprise,
            @AuthenticationPrincipal User currentUser) {

        log.info("POST /api/entreprises - Création d'une nouvelle entreprise");

        Entreprise created = entrepriseService.create(entreprise, currentUser);
        EntrepriseResponseDTO response = mapper.toEntrepriseDTO(created);

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * PUT /api/entreprises/{id}
     * Met à jour une entreprise
     */
    @PutMapping("/{id}")
    public ResponseEntity<EntrepriseResponseDTO> updateEntreprise(
            @PathVariable Integer id,
            @RequestBody Entreprise entreprise) {

        log.info("PUT /api/entreprises/{} - Mise à jour de l'entreprise", id);

        Entreprise updated = entrepriseService.update(id, entreprise);
        EntrepriseResponseDTO response = mapper.toEntrepriseDTO(updated);

        return ResponseEntity.ok(response);
    }

    /**
     * DELETE /api/entreprises/{id}
     * Supprime une entreprise
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteEntreprise(@PathVariable Integer id) {
        log.info("DELETE /api/entreprises/{} - Suppression de l'entreprise", id);

        entrepriseService.delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * POST /api/entreprises/{id}/activate
     * Active une entreprise
     */
    @PostMapping("/{id}/activate")
    public ResponseEntity<EntrepriseResponseDTO> activateEntreprise(@PathVariable Integer id) {
        log.info("POST /api/entreprises/{}/activate - Activation de l'entreprise", id);

        Entreprise activated = entrepriseService.activateEntreprise(id);
        EntrepriseResponseDTO response = mapper.toEntrepriseDTO(activated);

        return ResponseEntity.ok(response);
    }

    /**
     * POST /api/entreprises/{id}/deactivate
     * Désactive une entreprise
     */
    @PostMapping("/{id}/deactivate")
    public ResponseEntity<EntrepriseResponseDTO> deactivateEntreprise(@PathVariable Integer id) {
        log.info("POST /api/entreprises/{}/deactivate - Désactivation de l'entreprise", id);

        Entreprise deactivated = entrepriseService.deactivateEntreprise(id);
        EntrepriseResponseDTO response = mapper.toEntrepriseDTO(deactivated);

        return ResponseEntity.ok(response);
    }

    /**
     * POST /api/entreprises/{id}/update-note
     * Met à jour la note moyenne
     */
    @PostMapping("/{id}/update-note")
    public ResponseEntity<EntrepriseResponseDTO> updateNoteMoyenne(
            @PathVariable Integer id,
            @RequestParam BigDecimal note) {

        log.info("POST /api/entreprises/{}/update-note - Mise à jour de la note", id);

        entrepriseService.updateNoteMoyenne(id, note);

        return entrepriseService.findById(id)
                .map(mapper::toEntrepriseDTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
}



============================================================
FILE: FirebaseSyncController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.service.FirebaseSyncService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/sync")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Synchronisation Firebase", description = "Endpoints pour la synchronisation bidirectionnelle PostgreSQL ↔ Firebase")
public class FirebaseSyncController {

    private final FirebaseSyncService firebaseSyncService;

    // ==================== SYNCHRONISATION COMPLÈTE ====================

    @PostMapping("/all")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation bidirectionnelle complète",
            description = "Synchronise toutes les données entre PostgreSQL et Firebase dans les deux sens"
    )
    public ResponseEntity<Map<String, Object>> syncAll() {
        log.info("=== Démarrage synchronisation bidirectionnelle complète ===");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncAll();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", result.isSuccess() ?
                    "Synchronisation complète réussie" :
                    "Synchronisation complète avec erreurs");
            response.put("totalSuccess", result.getTotalSuccess());
            response.put("totalErrors", result.getTotalErrors());
            response.put("details", Map.of(
                    "successCounts", result.getSuccessCounts(),
                    "errorCounts", result.getErrorCounts()
            ));

            if (!result.isSuccess()) {
                response.put("errorMessage", result.getErrorMessage());
            }

            log.info("Synchronisation terminée - Succès: {} | Erreurs: {}",
                    result.getTotalSuccess(), result.getTotalErrors());

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur lors de la synchronisation complète", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== POSTGRES → FIREBASE ====================

    @PostMapping("/postgres-to-firebase")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation PostgreSQL → Firebase",
            description = "Envoie toutes les modifications locales (PostgreSQL) vers Firebase"
    )
    public ResponseEntity<Map<String, Object>> syncPostgresToFirebase() {
        log.info("Démarrage synchronisation PostgreSQL → Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncPostgresToFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Synchronisation PostgreSQL → Firebase terminée");
            response.put("totalSuccess", result.getTotalSuccess());
            response.put("totalErrors", result.getTotalErrors());
            response.put("successCounts", result.getSuccessCounts());
            response.put("errorCounts", result.getErrorCounts());

            if (!result.isSuccess()) {
                response.put("errorMessage", result.getErrorMessage());
            }

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur synchronisation PostgreSQL → Firebase", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== FIREBASE → POSTGRES ====================

    @PostMapping("/firebase-to-postgres")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation Firebase → PostgreSQL",
            description = "Récupère toutes les modifications distantes (Firebase) vers PostgreSQL"
    )
    public ResponseEntity<Map<String, Object>> syncFirebaseToPostgres() {
        log.info("Démarrage synchronisation Firebase → PostgreSQL");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncFirebaseToPostgres();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Synchronisation Firebase → PostgreSQL terminée");
            response.put("totalSuccess", result.getTotalSuccess());
            response.put("totalErrors", result.getTotalErrors());
            response.put("successCounts", result.getSuccessCounts());
            response.put("errorCounts", result.getErrorCounts());

            if (!result.isSuccess()) {
                response.put("errorMessage", result.getErrorMessage());
            }

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur synchronisation Firebase → PostgreSQL", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== SYNCHRONISATION PAR ENTITÉ ====================

    @PostMapping("/users")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation utilisateurs (PostgreSQL → Firebase)",
            description = "Synchronise uniquement les utilisateurs non synchronisés vers Firebase Authentication et Firestore"
    )
    public ResponseEntity<Map<String, Object>> syncUsers() {
        log.info("Synchronisation des utilisateurs vers Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncPostgresToFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Synchronisation des utilisateurs terminée");
            response.put("usersSuccess", result.getSuccessCounts().getOrDefault("users", 0));
            response.put("usersErrors", result.getErrorCounts().getOrDefault("users", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur synchronisation utilisateurs", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation des utilisateurs",
                            "error", e.getMessage()
                    ));
        }
    }

    @PostMapping("/signalements")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation signalements (PostgreSQL → Firebase)",
            description = "Synchronise uniquement les signalements non synchronisés vers Firestore"
    )
    public ResponseEntity<Map<String, Object>> syncSignalements() {
        log.info("Synchronisation des signalements vers Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncPostgresToFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Synchronisation des signalements terminée");
            response.put("signalementsSuccess", result.getSuccessCounts().getOrDefault("signalements", 0));
            response.put("signalementsErrors", result.getErrorCounts().getOrDefault("signalements", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur synchronisation signalements", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation des signalements",
                            "error", e.getMessage()
                    ));
        }
    }

    @PostMapping("/entreprises")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Synchronisation entreprises (PostgreSQL → Firebase)",
            description = "Synchronise toutes les entreprises vers Firestore"
    )
    public ResponseEntity<Map<String, Object>> syncEntreprises() {
        log.info("Synchronisation des entreprises vers Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncPostgresToFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Synchronisation des entreprises terminée");
            response.put("entreprisesSuccess", result.getSuccessCounts().getOrDefault("entreprises", 0));
            response.put("entreprisesErrors", result.getErrorCounts().getOrDefault("entreprises", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur synchronisation entreprises", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la synchronisation des entreprises",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== SYNCHRONISATION INVERSE (FIREBASE → POSTGRES) ====================

    @PostMapping("/pull-users")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Récupération utilisateurs (Firebase → PostgreSQL)",
            description = "Met à jour les utilisateurs PostgreSQL avec les données de Firebase"
    )
    public ResponseEntity<Map<String, Object>> pullUsers() {
        log.info("Récupération des utilisateurs depuis Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncUsersFromFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Récupération des utilisateurs terminée");
            response.put("usersUpdated", result.getSuccessCounts().getOrDefault("users_updated", 0));
            response.put("usersNotFound", result.getErrorCounts().getOrDefault("users_not_found", 0));
            response.put("usersErrors", result.getErrorCounts().getOrDefault("users", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur récupération utilisateurs", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la récupération des utilisateurs",
                            "error", e.getMessage()
                    ));
        }
    }

    @PostMapping("/pull-signalements")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Récupération signalements (Firebase → PostgreSQL)",
            description = "Met à jour ou crée les signalements PostgreSQL avec les données de Firebase"
    )
    public ResponseEntity<Map<String, Object>> pullSignalements() {
        log.info("Récupération des signalements depuis Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncSignalementsFromFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Récupération des signalements terminée");
            response.put("signalementsCreated", result.getSuccessCounts().getOrDefault("signalements_created", 0));
            response.put("signalementsUpdated", result.getSuccessCounts().getOrDefault("signalements_updated", 0));
            response.put("signalementsErrors", result.getErrorCounts().getOrDefault("signalements", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur récupération signalements", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la récupération des signalements",
                            "error", e.getMessage()
                    ));
        }
    }

    @PostMapping("/pull-entreprises")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN')")
    @Operation(
            summary = "Récupération entreprises (Firebase → PostgreSQL)",
            description = "Met à jour ou crée les entreprises PostgreSQL avec les données de Firebase"
    )
    public ResponseEntity<Map<String, Object>> pullEntreprises() {
        log.info("Récupération des entreprises depuis Firebase");

        try {
            FirebaseSyncService.SyncResult result = firebaseSyncService.syncEntreprisesFromFirebase();

            Map<String, Object> response = new HashMap<>();
            response.put("success", result.isSuccess());
            response.put("message", "Récupération des entreprises terminée");
            response.put("entreprisesCreated", result.getSuccessCounts().getOrDefault("entreprises_created", 0));
            response.put("entreprisesUpdated", result.getSuccessCounts().getOrDefault("entreprises_updated", 0));
            response.put("entreprisesErrors", result.getErrorCounts().getOrDefault("entreprises", 0));

            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Erreur récupération entreprises", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la récupération des entreprises",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== STATUT DE LA SYNCHRONISATION ====================

    @GetMapping("/status")
    @PreAuthorize("hasAnyRole('MANAGER', 'ADMIN', 'UTILISATEUR')")
    @Operation(
            summary = "Statut de la synchronisation",
            description = "Retourne le nombre d'entités non synchronisées"
    )
    public ResponseEntity<Map<String, Object>> getSyncStatus() {
        log.debug("Récupération du statut de synchronisation");

        try {
            // Cette méthode devrait être implémentée dans le service
            Map<String, Object> status = new HashMap<>();
            status.put("message", "Statut de synchronisation");
            status.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.ok(status);
        } catch (Exception e) {
            log.error("Erreur récupération statut", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of(
                            "success", false,
                            "message", "Erreur lors de la récupération du statut",
                            "error", e.getMessage()
                    ));
        }
    }

    // ==================== HEALTH CHECK ====================

    @GetMapping("/health")
    @Operation(
            summary = "Vérification de la connectivité Firebase",
            description = "Vérifie que la connexion à Firebase fonctionne correctement"
    )
    public ResponseEntity<Map<String, Object>> healthCheck() {
        log.debug("Vérification santé Firebase");

        try {
            Map<String, Object> health = new HashMap<>();
            health.put("status", "UP");
            health.put("message", "Firebase connecté");
            health.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.ok(health);
        } catch (Exception e) {
            log.error("Erreur health check Firebase", e);
            return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                    .body(Map.of(
                            "status", "DOWN",
                            "message", "Firebase non disponible",
                            "error", e.getMessage()
                    ));
        }
    }
}



============================================================
FILE: HistoriqueStatusController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.HistoriqueStatus;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.service.HistoriqueStatusService;
import mg.projetfinal.service.SignalementService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/historiques")
@RequiredArgsConstructor
@Slf4j
public class HistoriqueStatusController {

    private final HistoriqueStatusService historiqueStatusService;
    private final SignalementService signalementService;

    /**
     * GET /api/historiques
     * Récupère tous les historiques
     */
    @GetMapping
    public ResponseEntity<List<HistoriqueStatus>> getAllHistoriques() {
        log.info("GET /api/historiques - Récupération de tous les historiques");
        
        List<HistoriqueStatus> historiques = historiqueStatusService.findAll();
        return ResponseEntity.ok(historiques);
    }

    /**
     * GET /api/historiques/{id}
     * Récupère un historique par ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<HistoriqueStatus> getHistoriqueById(@PathVariable Long id) {
        log.info("GET /api/historiques/{} - Récupération de l'historique", id);
        
        return historiqueStatusService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * GET /api/historiques/signalement/{signalementId}
     * Récupère l'historique d'un signalement
     */
    @GetMapping("/signalement/{signalementId}")
    public ResponseEntity<List<HistoriqueStatus>> getHistoriqueBySignalement(@PathVariable Long signalementId) {
        log.info("GET /api/historiques/signalement/{} - Récupération de l'historique", signalementId);
        
        List<HistoriqueStatus> historiques = historiqueStatusService.getStatusHistory(signalementId);
        return ResponseEntity.ok(historiques);
    }

    /**
     * GET /api/historiques/signalement/{signalementId}/dernier
     * Récupère le dernier changement de statut
     */
    @GetMapping("/signalement/{signalementId}/dernier")
    public ResponseEntity<HistoriqueStatus> getLastStatusChange(@PathVariable Long signalementId) {
        log.info("GET /api/historiques/signalement/{}/dernier - Dernier changement", signalementId);
        
        Signalement signalement = signalementService.findById(signalementId)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé"));
        
        HistoriqueStatus lastChange = historiqueStatusService.getLastStatusChange(signalement);
        
        if (lastChange == null) {
            return ResponseEntity.notFound().build();
        }
        
        return ResponseEntity.ok(lastChange);
    }

    /**
     * DELETE /api/historiques/{id}
     * Supprime un historique
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteHistorique(@PathVariable Long id) {
        log.info("DELETE /api/historiques/{} - Suppression de l'historique", id);
        
        historiqueStatusService.delete(id);
        return ResponseEntity.noContent().build();
    }
}



============================================================
FILE: PhotoSignalementController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import mg.projetfinal.dto.PhotoSignalementDTO;
import mg.projetfinal.entity.PhotoSignalement;
import mg.projetfinal.entity.Session;
import mg.projetfinal.entity.User;
import mg.projetfinal.service.AuthService;
import mg.projetfinal.service.PhotoSignalementService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/photos")
@RequiredArgsConstructor
@Tag(name = "Photos", description = "API de gestion des photos de signalement")
public class PhotoSignalementController {

    private final PhotoSignalementService photoService;
    private final AuthService authService;

    @PostMapping("/signalement/{signalementId}")
    @Operation(summary = "Ajouter une photo à un signalement")
    public ResponseEntity<?> addPhoto(
            @PathVariable Long signalementId,
            @RequestBody PhotoRequest request,
            HttpServletRequest httpRequest) {
        try {
            User user = getCurrentUser(httpRequest);

            PhotoSignalement photo = photoService.addPhoto(
                    signalementId,
                    request.getUrl(),
                    request.getDescription(),
                    user
            );

            return ResponseEntity.status(HttpStatus.CREATED).body(toDTO(photo));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    @GetMapping("/signalement/{signalementId}")
    @Operation(summary = "Récupérer toutes les photos d'un signalement")
    public ResponseEntity<?> getPhotosBySignalement(@PathVariable Long signalementId) {
        try {
            List<PhotoSignalement> photos = photoService.getPhotosBySignalement(signalementId);
            List<PhotoSignalementDTO> dtos = photos.stream()
                    .map(this::toDTO)
                    .collect(Collectors.toList());
            return ResponseEntity.ok(dtos);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    @GetMapping("/signalement/{signalementId}/principale")
    @Operation(summary = "Récupérer la photo principale d'un signalement")
    public ResponseEntity<?> getPhotoPrincipale(@PathVariable Long signalementId) {
        try {
            PhotoSignalement photo = photoService.getPhotoPrincipale(signalementId);
            if (photo == null) {
                return ResponseEntity.notFound().build();
            }
            return ResponseEntity.ok(toDTO(photo));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    @PutMapping("/{photoId}/principale")
    @Operation(summary = "Définir une photo comme principale")
    public ResponseEntity<?> setPrincipale(@PathVariable Long photoId) {
        try {
            PhotoSignalement photo = photoService.setPrincipale(photoId);
            return ResponseEntity.ok(toDTO(photo));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    @DeleteMapping("/{photoId}")
    @Operation(summary = "Supprimer une photo")
    public ResponseEntity<?> deletePhoto(@PathVariable Long photoId) {
        try {
            photoService.deletePhoto(photoId);
            return ResponseEntity.ok(new SuccessResponse(true, "Photo supprimée avec succès"));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    @PutMapping("/signalement/{signalementId}/reorder")
    @Operation(summary = "Réordonner les photos d'un signalement")
    public ResponseEntity<?> reorderPhotos(
            @PathVariable Long signalementId,
            @RequestBody ReorderRequest request) {
        try {
            photoService.reorderPhotos(signalementId, request.getPhotoIds());
            return ResponseEntity.ok(new SuccessResponse(true, "Photos réordonnées avec succès"));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(new ErrorResponse(false, e.getMessage()));
        }
    }

    private PhotoSignalementDTO toDTO(PhotoSignalement photo) {
        return PhotoSignalementDTO.builder()
                .id(photo.getId())
                .url(photo.getUrl())
                .description(photo.getDescription())
                .ordre(photo.getOrdre())
                .isPrincipale(photo.getIsPrincipale())
                .uploadedBy(photo.getUploadedBy() != null ? photo.getUploadedBy().getName() : null)
                .createdAt(photo.getCreatedAt().toString())
                .build();
    }

    private User getCurrentUser(HttpServletRequest request) {
        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            throw new RuntimeException("Non authentifié");
        }
        String token = authHeader.substring(7);
        return authService.validateSession(token)
                .map(Session::getUser)
                .orElseThrow(() -> new RuntimeException("Session invalide"));
    }

    @lombok.Data
    static class PhotoRequest {
        private String url;
        private String description;
    }

    @lombok.Data
    static class ReorderRequest {
        private List<Long> photoIds;
    }

    @lombok.Data
    @lombok.AllArgsConstructor
    static class SuccessResponse {
        private Boolean success;
        private String message;
    }

    @lombok.Data
    @lombok.AllArgsConstructor
    static class ErrorResponse {
        private Boolean success;
        private String message;
    }
}



============================================================
FILE: SignalementActionController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.entity.Entreprise;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementAction;
import mg.projetfinal.entity.User;
import mg.projetfinal.service.SignalementActionService;
import mg.projetfinal.service.EntrepriseService;
import mg.projetfinal.service.SignalementService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/actions")
@RequiredArgsConstructor
@Slf4j
@CrossOrigin(origins = "*")
public class SignalementActionController {

    private final SignalementActionService actionService;
    private final SignalementService signalementService;
    private final EntrepriseService entrepriseService;

    /**
     * GET /api/actions
     * Récupère toutes les actions
     */
    @GetMapping
    public ResponseEntity<List<SignalementAction>> getAllActions() {
        log.info("GET /api/actions - Récupération de toutes les actions");
        
        List<SignalementAction> actions = actionService.findAll();
        return ResponseEntity.ok(actions);
    }

    /**
     * GET /api/actions/{id}
     * Récupère une action par ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<SignalementAction> getActionById(@PathVariable Long id) {
        log.info("GET /api/actions/{} - Récupération de l'action", id);
        
        return actionService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * GET /api/actions/signalement/{signalementId}
     * Récupère les actions d'un signalement
     */
    @GetMapping("/signalement/{signalementId}")
    public ResponseEntity<List<SignalementAction>> getActionsBySignalement(@PathVariable Long signalementId) {
        log.info("GET /api/actions/signalement/{} - Récupération des actions", signalementId);
        
        Signalement signalement = signalementService.findById(signalementId)
                .orElseThrow(() -> new IllegalArgumentException("Signalement non trouvé"));
        
        List<SignalementAction> actions = actionService.findBySignalement(signalement);
        return ResponseEntity.ok(actions);
    }

    /**
     * GET /api/actions/entreprise/{entrepriseId}
     * Récupère les actions d'une entreprise
     */
    @GetMapping("/entreprise/{entrepriseId}")
    public ResponseEntity<List<SignalementAction>> getActionsByEntreprise(@PathVariable Integer entrepriseId) {
        log.info("GET /api/actions/entreprise/{} - Récupération des actions", entrepriseId);
        
        Entreprise entreprise = entrepriseService.findById(entrepriseId)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée"));
        
        List<SignalementAction> actions = actionService.findByEntreprise(entreprise);
        return ResponseEntity.ok(actions);
    }

    /**
     * GET /api/actions/en-cours
     * Récupère les actions en cours
     */
    @GetMapping("/en-cours")
    public ResponseEntity<List<SignalementAction>> getActionsEnCours() {
        log.info("GET /api/actions/en-cours - Récupération des actions en cours");
        
        List<SignalementAction> actions = actionService.findActionsEnCours();
        return ResponseEntity.ok(actions);
    }

    /**
     * GET /api/actions/en-retard
     * Récupère les actions en retard
     */
    @GetMapping("/en-retard")
    public ResponseEntity<List<SignalementAction>> getActionsEnRetard() {
        log.info("GET /api/actions/en-retard - Récupération des actions en retard");
        
        List<SignalementAction> actions = actionService.findActionsEnRetard();
        return ResponseEntity.ok(actions);
    }

    /**
     * POST /api/actions
     * Crée une nouvelle action
     */
    @PostMapping
    public ResponseEntity<SignalementAction> createAction(
            @RequestBody SignalementAction action,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions - Création d'une nouvelle action");
        
        SignalementAction created = actionService.create(action, currentUser);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    /**
     * PUT /api/actions/{id}
     * Met à jour une action
     */
    @PutMapping("/{id}")
    public ResponseEntity<SignalementAction> updateAction(
            @PathVariable Long id,
            @RequestBody SignalementAction action,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("PUT /api/actions/{} - Mise à jour de l'action", id);
        
        SignalementAction updated = actionService.update(id, action, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * DELETE /api/actions/{id}
     * Supprime une action
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteAction(@PathVariable Long id) {
        log.info("DELETE /api/actions/{} - Suppression de l'action", id);
        
        actionService.delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * POST /api/actions/{id}/assigner-entreprise
     * Assigne une entreprise à une action
     */
    @PostMapping("/{id}/assigner-entreprise")
    public ResponseEntity<SignalementAction> assignerEntreprise(
            @PathVariable Long id,
            @RequestParam Integer entrepriseId,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions/{}/assigner-entreprise - Assignation entreprise {}", id, entrepriseId);
        
        Entreprise entreprise = entrepriseService.findById(entrepriseId)
                .orElseThrow(() -> new IllegalArgumentException("Entreprise non trouvée"));
        
        SignalementAction updated = actionService.assignerEntreprise(id, entreprise, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * POST /api/actions/{id}/demarrer
     * Démarre les travaux
     */
    @PostMapping("/{id}/demarrer")
    public ResponseEntity<SignalementAction> demarrerTravaux(
            @PathVariable Long id,
            @RequestParam(required = false) String dateDebut,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions/{}/demarrer - Démarrage des travaux", id);
        
        LocalDateTime dateDebutTravaux = dateDebut != null 
                ? LocalDateTime.parse(dateDebut) 
                : null;
        
        SignalementAction updated = actionService.demarrerTravaux(id, dateDebutTravaux, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * POST /api/actions/{id}/terminer
     * Termine les travaux
     */
    @PostMapping("/{id}/terminer")
    public ResponseEntity<SignalementAction> terminerTravaux(
            @PathVariable Long id,
            @RequestParam boolean conformes,
            @RequestParam(required = false) String commentaire,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions/{}/terminer - Fin des travaux", id);
        
        SignalementAction updated = actionService.terminerTravaux(id, conformes, commentaire, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * POST /api/actions/{id}/photos-avant
     * Ajoute des photos avant travaux
     */
    @PostMapping("/{id}/photos-avant")
    public ResponseEntity<SignalementAction> ajouterPhotosAvant(
            @PathVariable Long id,
            @RequestBody String[] photos,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions/{}/photos-avant - Ajout de {} photos", id, photos.length);
        
        SignalementAction updated = actionService.ajouterPhotosAvant(id, photos, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * POST /api/actions/{id}/photos-apres
     * Ajoute des photos après travaux
     */
    @PostMapping("/{id}/photos-apres")
    public ResponseEntity<SignalementAction> ajouterPhotosApres(
            @PathVariable Long id,
            @RequestBody String[] photos,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/actions/{}/photos-apres - Ajout de {} photos", id, photos.length);
        
        SignalementAction updated = actionService.ajouterPhotosApres(id, photos, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * PUT /api/actions/{id}/budget
     * Met à jour le budget
     */
    @PutMapping("/{id}/budget")
    public ResponseEntity<SignalementAction> updateBudget(
            @PathVariable Long id,
            @RequestParam BigDecimal budget,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("PUT /api/actions/{}/budget - Mise à jour du budget", id);
        
        SignalementAction updated = actionService.updateBudget(id, budget, currentUser);
        return ResponseEntity.ok(updated);
    }

    /**
     * GET /api/actions/statistics
     * Récupère les statistiques des actions
     */
    @GetMapping("/statistics")
    public ResponseEntity<ActionStatisticsDTO> getStatistics() {
        log.info("GET /api/actions/statistics - Récupération des statistiques");
        
        ActionStatisticsDTO stats = ActionStatisticsDTO.builder()
                .totalActions(actionService.findAll().size())
                .actionsEnCours(actionService.countActionsEnCours())
                .actionsEnRetard(actionService.countActionsEnRetard())
                .actionsTerminees(actionService.countActionsTerminees())
                .budgetTotal(actionService.calculateBudgetTotal())
                .build();
        
        return ResponseEntity.ok(stats);
    }
}

// DTO pour les statistiques des actions
@lombok.Data
@lombok.Builder
@lombok.NoArgsConstructor
@lombok.AllArgsConstructor
class ActionStatisticsDTO {
    private Integer totalActions;
    private Long actionsEnCours;
    private Long actionsEnRetard;
    private Long actionsTerminees;
    private BigDecimal budgetTotal;
}



============================================================
FILE: SignalementController.java
PACKAGE: mg.projetfinal.controller
============================================================

package mg.projetfinal.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.dto.*;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.mapper.SignalementMapper;
import mg.projetfinal.service.SignalementService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.math.BigDecimal;
import java.util.List;

@RestController
@RequestMapping("/api/signalements")
@RequiredArgsConstructor
@Slf4j
//@Validated
public class SignalementController {

    private final SignalementService signalementService;
    private final SignalementMapper signalementMapper;

    /**
     * GET /api/signalements
     * Récupère tous les signalements
     */
    @GetMapping
    public ResponseEntity<List<SignalementResponseDTO>> getAllSignalements() {
        log.info("GET /api/signalements - Récupération de tous les signalements");
        
        List<Signalement> signalements = signalementService.findAllOrderByDateDesc();
        List<SignalementResponseDTO> response = signalementMapper.toResponseDTOList(signalements);
        
        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/signalements/{id}
     * Récupère un signalement par ID
     */
    @GetMapping("/{id}")
    public ResponseEntity<SignalementResponseDTO> getSignalementById(@PathVariable Long id) {
        log.info("GET /api/signalements/{} - Récupération du signalement", id);
        
        return signalementService.findById(id)
                .map(signalementMapper::toResponseDTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * GET /api/signalements/status/{status}
     * Récupère les signalements par statut
     */
    @GetMapping("/status/{statusCode}")
    public ResponseEntity<List<SignalementResponseDTO>> getSignalementsByStatus(@PathVariable String statusCode) {
        log.info("GET /api/signalements/status/{} - Récupération par statut", statusCode);
        
        List<Signalement> signalements = signalementService.findByStatusCode(statusCode);
        List<SignalementResponseDTO> response = signalementMapper.toResponseDTOList(signalements);
        
        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/signalements/map
     * Récupère les signalements pour la carte
     */
    @GetMapping("/map")
    public ResponseEntity<List<SignalementResponseDTO>> getSignalementsForMap() {
        log.info("GET /api/signalements/map - Récupération pour la carte");
        
        List<Signalement> signalements = signalementService.findAll();
        List<SignalementResponseDTO> response = signalementMapper.toResponseDTOList(signalements);
        
        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/signalements/statistics
     * Récupère les statistiques des signalements
     */
    @GetMapping("/statistics")
    public ResponseEntity<StatisticsDTO> getStatistics() {
        log.info("GET /api/signalements/statistics - Récupération des statistiques");
        
        List<Signalement> signalements = signalementService.findAll();
        
        int total = signalements.size();
        int totalSurface = signalements.stream()
                .mapToInt(s -> {
                    var action = s.getActiveAction();
                    return action != null && action.getSurfaceM2() != null 
                            ? action.getSurfaceM2().intValue() : 0;
                })
                .sum();
        
        BigDecimal totalBudget = signalements.stream()
                .map(s -> {
                    var action = s.getActiveAction();
                    return action != null && action.getBudget() != null 
                            ? action.getBudget() : BigDecimal.ZERO;
                })
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        long nouveau = signalementService.countNouveau();
        long enCours = signalementService.countEnCours();
        long termine = signalementService.countTermine();
        
        double avancement = total > 0 ? ((double) termine / total) * 100 : 0;
        
        StatisticsDTO stats = StatisticsDTO.builder()
                .total(total)
                .totalSurface(totalSurface)
                .totalBudget(totalBudget)
                .nouveau((int) nouveau)
                .enCours((int) enCours)
                .termine((int) termine)
                .avancement(Math.round(avancement * 10.0) / 10.0)
                .build();
        
        return ResponseEntity.ok(stats);
    }

    /**
     * POST /api/signalements
     * Crée un nouveau signalement
     */
    @PostMapping
    public ResponseEntity<SignalementResponseDTO> createSignalement(
            @Valid @RequestBody CreateSignalementDTO dto,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/signalements - Création d'un nouveau signalement");
        
        // TODO: Récupérer le statut par défaut ou utiliser dto.statusId
        // SignalementStatus status = statusService.findById(dto.getStatusId()).orElseThrow();
        
        Signalement signalement = Signalement.builder()
                .latitude(dto.getLatitude())
                .longitude(dto.getLongitude())
                .description(dto.getDescription())
                .adresse(dto.getAdresse())
                .photoUrl(dto.getPhotoUrl())
                // .status(status)
                .build();
        
        Signalement created = signalementService.create(signalement, currentUser);
        SignalementResponseDTO response = signalementMapper.toResponseDTO(created);
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * PUT /api/signalements/{id}
     * Met à jour un signalement
     */
    @PutMapping("/{id}")
    public ResponseEntity<SignalementResponseDTO> updateSignalement(
            @PathVariable Long id,
            @Valid @RequestBody CreateSignalementDTO dto) {
        
        log.info("PUT /api/signalements/{} - Mise à jour du signalement", id);
        
        Signalement signalement = Signalement.builder()
                .latitude(dto.getLatitude())
                .longitude(dto.getLongitude())
                .description(dto.getDescription())
                .adresse(dto.getAdresse())
                .photoUrl(dto.getPhotoUrl())
                .build();
        
        Signalement updated = signalementService.update(id, signalement);
        SignalementResponseDTO response = signalementMapper.toResponseDTO(updated);
        
        return ResponseEntity.ok(response);
    }

    /**
     * DELETE /api/signalements/{id}
     * Supprime un signalement
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteSignalement(@PathVariable Long id) {
        log.info("DELETE /api/signalements/{} - Suppression du signalement", id);
        
        signalementService.delete(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * GET /api/signalements/location
     * Recherche par localisation
     */
    @GetMapping("/location")
    public ResponseEntity<List<SignalementResponseDTO>> getSignalementsByLocation(
            @RequestParam BigDecimal latitude,
            @RequestParam BigDecimal longitude,
            @RequestParam(defaultValue = "5.0") double radiusKm) {
        
        log.info("GET /api/signalements/location - Recherche par localisation");
        
        List<Signalement> signalements = signalementService.findByLocation(latitude, longitude, radiusKm);
        List<SignalementResponseDTO> response = signalementMapper.toResponseDTOList(signalements);
        
        return ResponseEntity.ok(response);
    }

    /**
     * POST /api/signalements/{id}/change-status
     * Change le statut d'un signalement
     */
    @PostMapping("/{id}/change-status")
    public ResponseEntity<SignalementResponseDTO> changeStatus(
            @PathVariable Long id,
            @RequestParam Long newStatusId,
            @RequestParam(required = false) String commentaire,
            @AuthenticationPrincipal User currentUser) {
        
        log.info("POST /api/signalements/{}/change-status - Changement de statut", id);
        
        // TODO: Récupérer le nouveau statut
        // SignalementStatus newStatus = statusService.findById(newStatusId).orElseThrow();
        // Signalement updated = signalementService.changeStatus(id, newStatus, currentUser, commentaire);
        
        // Pour l'instant, retourner le signalement existant
        Signalement signalement = signalementService.findById(id).orElseThrow();
        SignalementResponseDTO response = signalementMapper.toResponseDTO(signalement);
        
        return ResponseEntity.ok(response);
    }
}



============================================================
FILE: SignalementStatusController.java
PACKAGE: mg.projetfinal.controller
============================================================

// SignalementStatusController.java
package mg.projetfinal.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import mg.projetfinal.dto.SignalementResponseDTO;
import mg.projetfinal.entity.Signalement;
import mg.projetfinal.entity.SignalementStatus;
import mg.projetfinal.entity.User;
import mg.projetfinal.mapper.SignalementMapper;
import mg.projetfinal.service.SignalementService;
import mg.projetfinal.service.SignalementStatusService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Contrôleur pour la gestion des statuts de signalements
 */
@RestController
@RequestMapping("/api/signalements/status")
@RequiredArgsConstructor
@Slf4j
public class SignalementStatusController {

    private final SignalementService signalementService;
    private final SignalementStatusService statusService;
    private final SignalementMapper mapper;

    /**
     * POST /api/signalements/{id}/synchroniser
     * Synchronise un signalement avec Firebase
     */
    @PostMapping("/{id}/synchroniser")
    public ResponseEntity<SignalementResponseDTO> synchroniserSignalement(
            @PathVariable Long id,
            @AuthenticationPrincipal User currentUser) {

        log.info("POST /api/signalements/{}/synchroniser - Synchronisation avec Firebase", id);

        Signalement signalement = signalementService.findById(id)
                .orElseThrow(() -> new RuntimeException("Signalement non trouvé"));

        // Logique de synchronisation Firebase ici
        signalement.setFirebaseSynced(true);
        Signalement synced = signalementService.create(signalement,currentUser);

        SignalementResponseDTO response = mapper.toResponseDTO(synced);
        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/signalements/{id}/detail
     * Récupère les détails complets d'un signalement
     * (surface, budget, entreprise, statut, rues)
     */
    @GetMapping("/{id}/detail")
    public ResponseEntity<SignalementResponseDTO> getDetailSignalement(@PathVariable Long id) {
        log.info("GET /api/signalements/{}/detail - Récupération des détails complets", id);

        return signalementService.findById(id)
                .map(mapper::toResponseDTO)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * PUT /api/signalements/{id}/status
     * Change le statut d'un signalement
     */
    @PutMapping("/{id}/status")
    public ResponseEntity<SignalementResponseDTO> setStatus(
            @PathVariable Long id,
            @RequestParam Long statusId,
            @RequestParam(required = false) String commentaire,
            @AuthenticationPrincipal User currentUser) {

        log.info("PUT /api/signalements/{}/status - Changement de statut vers {}", id, statusId);

        Signalement signalement = signalementService.findById(id)
                .orElseThrow(() -> new RuntimeException("Signalement non trouvé"));

        SignalementStatus newStatus = statusService.findById(statusId.intValue())
                .orElseThrow(() -> new RuntimeException("Statut non trouvé"));

        signalement.setStatus(newStatus);


        Signalement updated = signalementService.create(signalement,currentUser);

        SignalementResponseDTO response = mapper.toResponseDTO(updated);

        return ResponseEntity.ok(response);
    }

    /**
     * GET /api/signalements/statut-options
     * Récupère la liste des statuts disponibles pour sélection
     */
    @GetMapping("/statut-options")
    public ResponseEntity<List<SignalementStatus>> getStatutOptions() {
        log.info("GET /api/signalements/statut-options - Récupération des options de statut");

        List<SignalementStatus> statuts = statusService.findAllOrderByOrdre();
        return ResponseEntity.ok(statuts);
    }

    /**
     * POST /api/signalements/{id}/on-hover
     * Endpoint pour afficher une bulle d'information au survol
     * Retourne une liste de statuts pour sélection
     */
    @PostMapping("/{id}/on-hover")
    public ResponseEntity<List<SignalementStatus>> onHoverSignalement(@PathVariable Long id) {
        log.info("POST /api/signalements/{}/on-hover - Affichage des options de statut", id);

        // Vérifier que le signalement existe
        signalementService.findById(id)
                .orElseThrow(() -> new RuntimeException("Signalement non trouvé"));

        List<SignalementStatus> availableStatuses = statusService.findAllOrderByOrdre();
        return ResponseEntity.ok(availableStatuses);
    }

    /**
     * POST /api/signalements/{id}/set-status-from-detail
     * Intégration de setStatus lors du clic sur le bouton dans la vue détail
     */
    @PostMapping("/{id}/set-status-from-detail")
    public ResponseEntity<SignalementResponseDTO> setStatusFromDetail(
            @PathVariable Long id,
            @RequestParam Long newStatusId,
            @RequestParam(required = false) String commentaire,
            @AuthenticationPrincipal User currentUser) {

        log.info("POST /api/signalements/{}/set-status-from-detail - Changement de statut depuis détail", id);

        return setStatus(id, newStatusId, commentaire, currentUser);
    }
}



